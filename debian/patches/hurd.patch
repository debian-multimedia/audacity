Description: Fix missing NOFILE on GNU/Hurd
Author: Benjamin Drung <bdrung@ubuntu.com>

--- audacity-1.3.10.orig/lib-src/libnyquist/nyquist/cmt/userio.c
+++ audacity-1.3.10/lib-src/libnyquist/nyquist/cmt/userio.c
@@ -70,6 +70,7 @@ ascii_input = poll for char + CR->EOL co
 */
 
 #include "switches.h"
+#include <sys/resource.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -1205,6 +1206,7 @@ public int wait_ascii()
 #endif /* !UNIX_MACH */
 #endif
     char c;
+    struct rlimit file_limit;
 
     if (abort_flag == ABORT_LEVEL) return ABORT_CHAR;
     if (abort_flag == BREAK_LEVEL) return BREAK_CHAR;
@@ -1233,7 +1235,8 @@ public int wait_ascii()
         FD_ZERO(&readfds);
         FD_SET(IOinputfd, &readfds);
         gflush();
-        select(NOFILE+1, &readfds, 0, 0, NULL);
+        getrlimit(RLIMIT_NOFILE, &file_limit);
+        select(file_limit.rlim_max+1, &readfds, 0, 0, NULL);
 #endif /* !UNIX_MACH */
 #endif /* ifdef UNIX */
     }
--- audacity-1.3.10.orig/lib-src/libnyquist/nyquist/cmt/midifns.c
+++ audacity-1.3.10/lib-src/libnyquist/nyquist/cmt/midifns.c
@@ -22,6 +22,7 @@
 *****************************************************************************/
 
 #include "switches.h"
+#include <sys/resource.h>
 
 #ifdef UNIX
 #include <sys/param.h>
@@ -376,6 +377,7 @@ void eventwait(timeout)
     struct timeval unix_timeout;
     struct timeval *waitspec = NULL;
     fd_set readfds;
+    struct rlimit file_limit;
 
     FD_ZERO(&readfds);
     FD_SET(MI_CONNECTION(midiconn), &readfds);
@@ -387,7 +389,8 @@ void eventwait(timeout)
     unix_timeout.tv_usec = (timeout - (unix_timeout.tv_sec * 1000)) * 1000;
     waitspec = &unix_timeout;
     }
-    select(NOFILE+1, &readfds, 0, 0, waitspec);
+    getrlimit(RLIMIT_NOFILE, &file_limit);
+    select(file_limit.rlim_max+1, &readfds, 0, 0, waitspec);
     return;
 }
 #else /* !UNIX_ITC */
@@ -424,6 +427,7 @@ void eventwait(timeout)
 {
     struct timeval unix_timeout;
     struct timeval *waitspec = NULL;
+    struct rlimit file_limit;
 
     if (timeout >= 0) {
     timeout -= gettime();   /* convert to millisecond delay */
@@ -431,7 +435,8 @@ void eventwait(timeout)
     /* remainder become microsecs: */
     unix_timeout.tv_usec = (timeout - (unix_timeout.tv_sec * 1000)) * 1000;
     waitspec = &unix_timeout;
-    select(NOFILE+1, 0, 0, 0, waitspec);
+    getrlimit(RLIMIT_NOFILE, &file_limit);
+    select(file_limit.rlim_max+1, 0, 0, 0, waitspec);
     } else {
     int c = getc(stdin);
     ungetc(c, stdin);
@@ -445,6 +450,7 @@ void eventwait(timeout)
     struct timeval unix_timeout;
     struct timeval *waitspec = NULL;
     int readfds = 1 << IOinputfd;
+    struct rlimit file_limit;
 
     if (timeout >= 0) {
     timeout -= gettime();   /* convert to millisecond delay */
@@ -453,7 +459,8 @@ void eventwait(timeout)
     unix_timeout.tv_usec = (timeout - (unix_timeout.tv_sec * 1000)) * 1000;
     waitspec = &unix_timeout;
     }
-    select(NOFILE+1, &readfds, 0, 0, waitspec);
+    getrlimit(RLIMIT_NOFILE, &file_limit);
+    select(file_limit.rlim_max+1, &readfds, 0, 0, waitspec);
     return;
 }
 #endif /* BUFFERED_SYNCHRONOUS_INPUT */
