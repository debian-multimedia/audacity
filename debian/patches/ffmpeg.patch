Description: Add support for recent FFmpeg/libav versions
 This patch adds support for libav >= 0.8 (including libav 9 and 10) and
 FFmpeg >= 1.2 and drops support for libav < 0.8 and FFmpeg < 1.2.
 The changed source files are directly copied from SVN revision 13171.
Author: Michael Niedermayer <michaelni@gmx.at> and Benjamin Drung <bdrung@debian.org>
Bug: http://bugzilla.audacityteam.org/show_bug.cgi?id=540
Bug-Debian: http://bugs.debian.org/740755
Bug-Ubuntu: https://launchpad.net/bugs/1076928

--- a/src/FFmpeg.cpp
+++ b/src/FFmpeg.cpp
@@ -25,16 +25,6 @@
 
 #include <wx/file.h>
 
-#ifdef _DEBUG
-   #ifdef _MSC_VER
-      #undef THIS_FILE
-      static char*THIS_FILE= __FILE__;
-      #define new new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
-   #endif
-#endif
-
-#define UFILE_PROTOCOL "ufile"
-
 #if !defined(USE_FFMPEG)
 /// FFmpeg support may or may not be compiled in,
 /// but Preferences dialog requires this function nevertheless
@@ -81,8 +71,8 @@
    PickFFmpegLibs();
    if (FFmpegLibsInst->ValidLibsLoaded())
    {
-     DropFFmpegLibs();
-     return true;
+      DropFFmpegLibs();
+      return true;
    }
    if (!FFmpegLibsInst->LoadLibs(NULL,showerror))
    {
@@ -135,7 +125,7 @@
 void av_log_wx_callback(void* ptr, int level, const char* fmt, va_list vl)
 {
    //Most of this stuff is taken from FFmpeg tutorials and FFmpeg itself
-   int av_log_level = AV_LOG_WARNING;
+   int av_log_level = AV_LOG_INFO;
    AVClass* avc = ptr ? *(AVClass**)ptr : NULL;
    if (level > av_log_level)
       return;
@@ -165,7 +155,7 @@
    }
 #ifdef EXPERIMENTAL_OD_FFMPEG
 //if the decoding happens thru OD then this gets called from a non main thread, which means wxLogDebug
-//will crash.  
+//will crash.
 //TODO:find some workaround for the log.  perhaps use ODManager as a bridge. for now just print
    if(!wxThread::IsMain())
       printf("%s: %s\n",(char*)cpt.char_str(),(char*)printstring.char_str());
@@ -177,56 +167,18 @@
 //======================= Unicode aware uri protocol for FFmpeg
 // Code inspired from ffmpeg-users mailing list sample
 
-static int ufile_open(URLContext *h, const char *filename, int flags)
+static int ufile_read(void *opaque, uint8_t *buf, int size)
 {
-   wxString name(strchr(filename, ':') + 1, wxConvUTF8);
-   wxFile *f;
-   wxFile::OpenMode mode;
-
-   f = new wxFile;
-   if (!f) {
-      return AVERROR(ENOMEM);
-   }
-
-   // LLL:  These really should be logical AND tests, but on 2011/04/28, the URL_ open flags
-   //       changed in the FFmpeg source to values that were not compatible with previous
-   //       values.
-   //
-   //       Since Audacity doesn't use any other open flags (there aren't any others defined
-   //       anyway), making equality tests works for older and new FFmpeg headers.
-   if (flags == URL_RDWR) {
-      mode = wxFile::read_write;
-   } else if (flags == URL_WRONLY) {
-      mode = wxFile::write;
-   } else {
-      mode = wxFile::read;
-   }
-
-   if (!f->Open(name, mode)) {
-      delete f;
-      return AVERROR(ENOENT);
-   }
-
-   h->priv_data = (void *)f;
-
-   return 0;
+   int ret = (int)((wxFile *) opaque)->Read(buf, size);
+   return ret;
 }
 
-static int ufile_read(URLContext *h, unsigned char *buf, int size)
+static int ufile_write(void *opaque, uint8_t *buf, int size)
 {
-   return (int) ((wxFile *) h->priv_data)->Read(buf, size);
+   return (int) ((wxFile *) opaque)->Write(buf, size);
 }
 
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 68, 0)
-static int ufile_write(URLContext *h, unsigned char *buf, int size)
-#else
-static int ufile_write(URLContext *h, const unsigned char *buf, int size)
-#endif
-{
-   return (int) ((wxFile *) h->priv_data)->Write(buf, size);
-}
-
-static int64_t ufile_seek(URLContext *h, int64_t pos, int whence)
+static int64_t ufile_seek(void *opaque, int64_t pos, int whence)
 {
    wxSeekMode mode = wxFromStart;
 
@@ -237,73 +189,73 @@
    switch (whence & ~AVSEEK_FORCE)
    {
    case (SEEK_SET):
-     mode = wxFromStart;
-     break;
+      mode = wxFromStart;
+      break;
    case (SEEK_CUR):
-     mode = wxFromCurrent;
-     break;
+      mode = wxFromCurrent;
+      break;
    case (SEEK_END):
-     mode = wxFromEnd;
-     break;
+      mode = wxFromEnd;
+      break;
    case (AVSEEK_SIZE):
-     return ((wxFile *) h->priv_data)->Length();
+      return ((wxFile *) opaque)->Length();
    }
 
-   return ((wxFile *) h->priv_data)->Seek(pos, mode);
+   return ((wxFile *) opaque)->Seek(pos, mode);
 }
 
-static int ufile_close(URLContext *h)
+int ufile_close(AVIOContext *pb)
 {
-   wxFile *f = (wxFile *) h->priv_data;
+   wxFile *f = (wxFile *) pb->opaque;
 
    if (f) {
       f->Close();
       delete f;
    }
 
-    return 0;
+   return 0;
 }
 
-URLProtocol ufile_protocol = {
-    UFILE_PROTOCOL,
-    ufile_open,
-    ufile_read,
-    ufile_write,
-    ufile_seek,
-    ufile_close,
-};
-
 // Open a file with a (possibly) Unicode filename
 int ufile_fopen(AVIOContext **s, const wxString & name, int flags)
 {
-   wxString url(wxString(wxT(UFILE_PROTOCOL)) + wxT(":") + name);
-   URLContext *h;
-   int err;
+   wxFile *f;
+   wxFile::OpenMode mode;
+
+   f = new wxFile;
+   if (!f) {
+      return ENOMEM;
+   }
+
+   if (flags == (AVIO_FLAG_READ | AVIO_FLAG_WRITE)) {
+      delete f;
+      return EINVAL;
+   } else if (flags == AVIO_FLAG_WRITE) {
+      mode = wxFile::write;
+   } else {
+      mode = wxFile::read;
+   }
 
-   // Open the file using our custom protocol and passing the (possibly) Unicode
-   // filename.  We convert the name to UTF8 here and it will be converted back
-   // to original encoding in ufile_open().  This allows us to support Unicode
-   // filenames even though FFmpeg does not.
-   err = url_open(&h, (const char *) url.ToUTF8(), flags);
-   if (err < 0) {
-      return err;
+   if (!f->Open(name, mode)) {
+      delete f;
+      return ENOENT;
    }
 
-   // Associate the file with a context
-   err = url_fdopen(s, h);
-   if (err < 0) {
-      url_close(h);
-      return err;
+   *s = avio_alloc_context((unsigned char*)av_malloc(32768), 32768,
+                           flags & AVIO_FLAG_WRITE,
+                           /*opaque*/f,
+                           ufile_read,
+                           ufile_write,
+                           ufile_seek);
+   if (!*s) {
+      delete f;
+      return ENOMEM;
    }
 
    return 0;
 }
 
 
-// Size of probe buffer, for guessing file type from file contents
-#define PROBE_BUF_MIN 2048
-#define PROBE_BUF_MAX (1<<20)
-
 // Detect type of input file and open it if recognized. Routine
 // based on the av_open_input_file() libavformat function.
 int ufile_fopen_input(AVFormatContext **ic_ptr, wxString & name)
@@ -311,110 +263,32 @@
    wxFileName f(name);
    wxCharBuffer fname;
    const char *filename;
-   AVProbeData pd;
    AVIOContext *pb = NULL;
-   AVInputFormat *fmt = NULL;
-   AVInputFormat *fmt1;
-   int probe_size;
    int err;
 
-   // Create a dummy file name using the extension from the original
-   f.SetName(wxT(UFILE_PROTOCOL));
    fname = f.GetFullName().mb_str();
    filename = (const char *) fname;
 
-   // Initialize probe data...go ahead and preallocate the maximum buffer size.
-   pd.filename = filename;
-   pd.buf_size = 0;
-   pd.buf = (unsigned char *) av_malloc(PROBE_BUF_MAX + AVPROBE_PADDING_SIZE);
-   if (pd.buf == NULL) {
-      err = AVERROR(ENOMEM);
-      goto fail;
-   }
-
    // Open the file to prepare for probing
-   if ((err = ufile_fopen(&pb, name, URL_RDONLY)) < 0) {
+   if ((err = ufile_fopen(&pb, name, AVIO_FLAG_READ)) < 0) {
       goto fail;
    }
 
-   for (probe_size = PROBE_BUF_MIN; probe_size <= PROBE_BUF_MAX && !fmt; probe_size <<= 1) {
-      int score_max = probe_size < PROBE_BUF_MAX ? AVPROBE_SCORE_MAX / 4 : 0;
-
-      // Read up to a "probe_size" worth of data
-      pd.buf_size = avio_read(pb, pd.buf, probe_size);
-
-      // AWD: with zero-length input files buf_size can come back negative;
-      // this causes problems so we might as well just fail
-      if (pd.buf_size < 0) {
-         err = AVERROR_INVALIDDATA;
-         goto fail;
-      }
-
-      // Clear up to a "AVPROBE_PADDING_SIZE" worth of unused buffer
-      memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);
-
-      // Reposition file for succeeding scan
-      if (avio_seek(pb, 0, SEEK_SET) < 0) {
-         err = AVERROR(EIO);
-         goto fail;
-      }
-
-      // Scan all input formats
-      fmt = NULL;
-      for (fmt1 = av_iformat_next(NULL); fmt1 != NULL; fmt1 = av_iformat_next(fmt1)) {
-         int score = 0;
-
-         // Ignore the ones that are not file based
-         if (fmt1->flags & AVFMT_NOFILE) {
-            continue;
-         }
-
-         // If the format can probe the file then try that first
-         if (fmt1->read_probe) {
-            score = fmt1->read_probe(&pd);
-         }
-         // Otherwize, resort to extension matching if available
-         else if (fmt1->extensions) {
-            if (av_match_ext(filename, fmt1->extensions)) {
-               score = 50;
-            }
-         }
-
-         // Remember this format if it scored higher than a previous match
-         if (score > score_max) {
-            score_max = score;
-            fmt = fmt1;
-         }
-         else if (score == score_max) {
-            fmt = NULL;
-         }
-      }
-   }
-
-   // Didn't find a suitable format, so bail
-   if (!fmt) {
-      err = AVERROR(EILSEQ);
-      goto fail;
-   }
+   *ic_ptr = avformat_alloc_context();
+   (*ic_ptr)->pb = pb;
 
    // And finally, attempt to associate an input stream with the file
-   err = av_open_input_stream(ic_ptr, pb, filename, fmt, NULL);
+   err = avformat_open_input(ic_ptr, filename, NULL, NULL);
    if (err) {
       goto fail;
    }
 
-   // Done with the probe buffer
-   av_freep(&pd.buf);
-
    return 0;
 
 fail:
-   if (pd.buf) {
-      av_freep(&pd.buf);
-   }
 
    if (pb) {
-      avio_close(pb);
+      ufile_close(pb);
    }
 
    *ic_ptr = NULL;
@@ -461,7 +335,7 @@
 
 int import_ffmpeg_decode_frame(streamContext *sc, bool flushing)
 {
-   int      nBytesDecoded;          
+   int      nBytesDecoded;
    wxUint8 *pDecode = sc->m_pktDataPtr;
    int      nDecodeSiz = sc->m_pktRemainingSiz;
 
@@ -482,10 +356,32 @@
       }
    }
 
+   AVPacket avpkt;
+   av_init_packet(&avpkt);
+   avpkt.data = pDecode;
+   avpkt.size = nDecodeSiz;
+
+   AVFrame *frame = av_frame_alloc();
+   int got_output = 0;
+
+   nBytesDecoded =
+      avcodec_decode_audio4(sc->m_codecCtx,
+                            frame,                                   // out
+                            &got_output,                             // out
+                            &avpkt);                                 // in
+
+   if (nBytesDecoded < 0)
+   {
+      // Decoding failed. Don't stop.
+      return -1;
+   }
+
    sc->m_samplefmt = sc->m_codecCtx->sample_fmt;
-   sc->m_samplesize = av_get_bits_per_sample_format(sc->m_samplefmt) / 8;
+   sc->m_samplesize = av_get_bytes_per_sample(sc->m_samplefmt);
 
-   unsigned int newsize = FFMAX(sc->m_pkt.size * sc->m_samplesize, AVCODEC_MAX_AUDIO_FRAME_SIZE);
+   int channels = sc->m_codecCtx->channels;
+   unsigned int newsize = sc->m_samplesize * frame->nb_samples * channels;
+   sc->m_decodedAudioSamplesValidSiz = newsize;
    // Reallocate the audio sample buffer if it's smaller than the frame size.
    if (newsize > sc->m_decodedAudioSamplesSiz )
    {
@@ -503,38 +399,20 @@
          return -1;
       }
    }
-
-
-   sc->m_decodedAudioSamplesValidSiz = sc->m_decodedAudioSamplesSiz;
-
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
-   // avcodec_decode_audio3() expects the size of the output buffer as the 3rd parameter but
-   // also returns the number of bytes it decoded in the same parameter.
-   AVPacket avpkt;
-   av_init_packet(&avpkt);
-   avpkt.data = pDecode;
-   avpkt.size = nDecodeSiz;
-   nBytesDecoded =
-      avcodec_decode_audio3(sc->m_codecCtx,
-                            (int16_t *)sc->m_decodedAudioSamples,    // out
-                            &sc->m_decodedAudioSamplesValidSiz,      // in/out
-                            &avpkt);                                 // in
-#else
-   // avcodec_decode_audio2() expects the size of the output buffer as the 3rd parameter but
-   // also returns the number of bytes it decoded in the same parameter.
-   nBytesDecoded =
-      avcodec_decode_audio2(sc->m_codecCtx, 
-                            (int16_t *) sc->m_decodedAudioSamples,   // out
-                            &sc->m_decodedAudioSamplesValidSiz,      // in/out
-                            pDecode,                                 // in
-                            nDecodeSiz);                             // in
-#endif
-   if (nBytesDecoded < 0)
-   {
-      // Decoding failed. Don't stop.
-      return -1;
+   if (frame->data[1]) {
+      for (int i = 0; i<frame->nb_samples; i++) {
+         for (int ch = 0; ch<channels; ch++) {
+            memcpy(sc->m_decodedAudioSamples + sc->m_samplesize * (ch + channels*i),
+                  frame->extended_data[ch] + sc->m_samplesize*i,
+                  sc->m_samplesize);
+         }
+      }
+   } else {
+      memcpy(sc->m_decodedAudioSamples, frame->data[0], newsize);
    }
 
+   av_frame_free(&frame);
+
    // We may not have read all of the data from this packet. If so, the user can call again.
    // Whether or not they do depends on if m_pktRemainingSiz == 0 (they can check).
    sc->m_pktDataPtr += nBytesDecoded;
@@ -636,7 +514,7 @@
       "Where would I find the file '%s'?" instead if you want. */
       question.Printf(_("Where is '%s'?"), mName.c_str());
 
-      wxString path = FileSelector(question, 
+      wxString path = FileSelector(question,
          mLibPath.GetPath(),
          mLibPath.GetName(),
          wxT(""),
@@ -723,7 +601,7 @@
    else {
       path = GetLibAVFormatPath();
       name = GetLibAVFormatName();
-      wxLogMessage(wxT("mLibAVFormatPath is empty, starting with path '%s', name '%s'."), 
+      wxLogMessage(wxT("mLibAVFormatPath is empty, starting with path '%s', name '%s'."),
                   path.c_str(), name.c_str());
    }
 
@@ -781,7 +659,7 @@
          mLibAVFormatPath = path;
       }
    }
-   
+
 #if defined(__WXMAC__)
    // If not successful, try loading it from legacy path
    if (!mLibsLoaded && !GetLibAVFormatPath().IsEmpty()) {
@@ -815,16 +693,16 @@
       gPrefs->Read(wxT("/FFmpeg/NotFoundDontShow"),&dontShowDlg,0);
       if ((dontShowDlg == 0) && (showerr))
       {
-          dlg = new FFmpegNotFoundDialog(NULL);
-          dlg->ShowModal();
-          delete dlg;
+         dlg = new FFmpegNotFoundDialog(NULL);
+         dlg->ShowModal();
+         delete dlg;
       }
    }
    */
    // Oh well, just give up
    if (!ValidLibsLoaded()) {
       wxString msg = _("Failed to find compatible FFmpeg libraries.");
-      if (showerr) 
+      if (showerr)
          wxMessageBox(msg);
       wxLogError(msg);
       return false;
@@ -860,7 +738,7 @@
       // If the directory, where libavformat is, is not in PATH - add it
       if (!syspath.Contains(fmtdirsc) && !syspath.Contains(scfmtdir) && !syspath.Contains(fmtdir))
       {
-         wxLogWarning(wxT("FFmpeg directory is not in PATH."), fmtdir.c_str());
+         wxLogWarning(wxT("FFmpeg directory '%s' is not in PATH."), fmtdir.c_str());
          if (syspath.Last() == wxT(';'))
          {
             wxLogMessage(wxT("Temporarily appending '%s' to PATH..."), fmtdir.c_str());
@@ -909,8 +787,8 @@
       if (actual.GetFullPath().IsSameAs(name.GetFullPath())) {
          actual = FileNames::PathFromAddr(avformat->GetSymbol(wxT("avcodec_version")));
          if (actual.GetFullPath().IsSameAs(name.GetFullPath())) {
-             util = avformat;
-             codec = avformat;
+            util = avformat;
+            codec = avformat;
          }
       }
 
@@ -977,74 +855,45 @@
 
    wxLogMessage(wxT("Importing symbols..."));
    FFMPEG_INITDYN(avformat, av_register_all);
-   FFMPEG_INITDYN(avformat, av_find_stream_info);
+   FFMPEG_INITDYN(avformat, avformat_find_stream_info);
    FFMPEG_INITDYN(avformat, av_read_frame);
    FFMPEG_INITDYN(avformat, av_seek_frame);
-   FFMPEG_INITDYN(avformat, av_close_input_file);
-   FFMPEG_INITDYN(avformat, av_write_header);
+   FFMPEG_INITDYN(avformat, avformat_close_input);
+   FFMPEG_INITDYN(avformat, avformat_write_header);
    FFMPEG_INITDYN(avformat, av_interleaved_write_frame);
-   FFMPEG_INITDYN(avformat, av_iformat_next);
    FFMPEG_INITDYN(avformat, av_oformat_next);
-   FFMPEG_INITDYN(avformat, av_set_parameters);
-   FFMPEG_INITDYN(avformat, url_open_protocol);
-   FFMPEG_INITDYN(avformat, url_open);
-   FFMPEG_INITDYN(avformat, url_fdopen);
-   FFMPEG_INITDYN(avformat, url_close);
-   FFMPEG_INITDYN(avformat, url_fseek);
-   FFMPEG_INITDYN(avformat, url_fclose);
-   FFMPEG_INITDYN(avformat, av_new_stream);
+   FFMPEG_INITDYN(avformat, avformat_new_stream);
    FFMPEG_INITDYN(avformat, avformat_alloc_context);
    FFMPEG_INITDYN(avformat, av_write_trailer);
    FFMPEG_INITDYN(avformat, av_codec_get_tag);
    FFMPEG_INITDYN(avformat, avformat_version);
-   FFMPEG_INITDYN(avformat, av_open_input_stream);
-   FFMPEG_INITDYN(avformat, av_metadata_get);
-
-   FFMPEG_INITALT(avformat, av_register_protocol2, av_register_protocol);
-   FFMPEG_INITALT(avformat, avio_read, get_buffer);
-   FFMPEG_INITALT(avformat, avio_seek, url_fseek);
-   FFMPEG_INITALT(avformat, avio_close, url_fclose);
-   FFMPEG_INITALT(avformat, av_metadata_set2, av_metadata_set);
+   FFMPEG_INITDYN(avformat, avformat_open_input);
+   FFMPEG_INITDYN(avformat, av_dict_get);
+   FFMPEG_INITDYN(avformat, av_dict_set);
+   FFMPEG_INITDYN(avformat, avio_size);
+   FFMPEG_INITDYN(avformat, avio_alloc_context);
    FFMPEG_INITALT(avformat, av_guess_format, guess_format);
-   FFMPEG_INITALT(avformat, av_match_ext, match_ext);
 
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 58, 0)
    FFMPEG_INITDYN(avcodec, av_init_packet);
-#else
-   FFMPEG_INITDYN(avformat, av_init_packet);
-#endif
-
-#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(52, 31, 0)
    FFMPEG_INITDYN(avcodec, av_free_packet);
-#endif
-   FFMPEG_INITDYN(avcodec, avcodec_init);
    FFMPEG_INITDYN(avcodec, avcodec_find_encoder);
    FFMPEG_INITDYN(avcodec, avcodec_find_encoder_by_name);
    FFMPEG_INITDYN(avcodec, avcodec_find_decoder);
-   FFMPEG_INITDYN(avcodec, avcodec_get_context_defaults);
-   FFMPEG_INITDYN(avcodec, avcodec_open);
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
-   FFMPEG_INITDYN(avcodec, avcodec_decode_audio3);
-#else
-   FFMPEG_INITDYN(avcodec, avcodec_decode_audio2);
-#endif
-   FFMPEG_INITDYN(avcodec, avcodec_encode_audio);
+   FFMPEG_INITDYN(avcodec, avcodec_open2);
+   FFMPEG_INITDYN(avcodec, avcodec_decode_audio4);
+   FFMPEG_INITDYN(avcodec, avcodec_encode_audio2);
    FFMPEG_INITDYN(avcodec, avcodec_close);
    FFMPEG_INITDYN(avcodec, avcodec_register_all);
    FFMPEG_INITDYN(avcodec, avcodec_version);
-   FFMPEG_INITDYN(avcodec, av_fast_realloc);
    FFMPEG_INITDYN(avcodec, av_codec_next);
-
-   FFMPEG_INITALT(avcodec, av_get_bits_per_sample_format, av_get_bits_per_sample_fmt);
+   FFMPEG_INITDYN(avcodec, av_codec_is_encoder);
+   FFMPEG_INITDYN(avcodec, avcodec_fill_audio_frame);
+   FFMPEG_INITDYN(avcodec, av_get_bytes_per_sample);
 
    FFMPEG_INITDYN(avutil, av_free);
    FFMPEG_INITDYN(avutil, av_log_set_callback);
    FFMPEG_INITDYN(avutil, av_log_default_callback);
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    FFMPEG_INITDYN(avutil, av_fifo_alloc);
-#else
-   FFMPEG_INITDYN(avutil, av_fifo_init);
-#endif
    FFMPEG_INITDYN(avutil, av_fifo_generic_read);
    FFMPEG_INITDYN(avutil, av_fifo_realloc2);
    FFMPEG_INITDYN(avutil, av_fifo_free);
@@ -1054,15 +903,17 @@
    FFMPEG_INITDYN(avutil, av_freep);
    FFMPEG_INITDYN(avutil, av_rescale_q);
    FFMPEG_INITDYN(avutil, avutil_version);
+   FFMPEG_INITALT(avutil, av_frame_alloc, avcodec_alloc_frame);
+   FFMPEG_INITALT(avutil, av_frame_free, avcodec_free_frame);
+   FFMPEG_INITDYN(avutil, av_samples_get_buffer_size);
 
    wxLogMessage(wxT("All symbols loaded successfully. Initializing the library."));
 #endif
 
    //FFmpeg initialization
-   avcodec_init();
    avcodec_register_all();
    av_register_all();
-   
+
    wxLogMessage(wxT("Retrieving FFmpeg library version numbers:"));
    int avfver = avformat_version();
    int avcver = avcodec_version();
@@ -1071,14 +922,14 @@
    mAVFormatVersion = wxString::Format(wxT("%d.%d.%d"),avfver >> 16 & 0xFF, avfver >> 8 & 0xFF, avfver & 0xFF);
    mAVUtilVersion = wxString::Format(wxT("%d.%d.%d"),avuver >> 16 & 0xFF, avuver >> 8 & 0xFF, avuver & 0xFF);
 
-   wxLogMessage(wxT("   AVCodec version 0x%06x - %s (built against 0x%06x - %s)"), 
-                  avcver, mAVCodecVersion.c_str(), LIBAVCODEC_VERSION_INT, 
+   wxLogMessage(wxT("   AVCodec version 0x%06x - %s (built against 0x%06x - %s)"),
+                  avcver, mAVCodecVersion.c_str(), LIBAVCODEC_VERSION_INT,
                   wxString::FromUTF8(AV_STRINGIFY(LIBAVCODEC_VERSION)).c_str());
-   wxLogMessage(wxT("   AVFormat version 0x%06x - %s (built against 0x%06x - %s)"), 
-                  avfver, mAVFormatVersion.c_str(), LIBAVFORMAT_VERSION_INT, 
+   wxLogMessage(wxT("   AVFormat version 0x%06x - %s (built against 0x%06x - %s)"),
+                  avfver, mAVFormatVersion.c_str(), LIBAVFORMAT_VERSION_INT,
                   wxString::FromUTF8(AV_STRINGIFY(LIBAVFORMAT_VERSION)).c_str());
-   wxLogMessage(wxT("   AVUtil version 0x%06x - %s (built against 0x%06x - %s)"), 
-                  avuver,mAVUtilVersion.c_str(), LIBAVUTIL_VERSION_INT, 
+   wxLogMessage(wxT("   AVUtil version 0x%06x - %s (built against 0x%06x - %s)"),
+                  avuver,mAVUtilVersion.c_str(), LIBAVUTIL_VERSION_INT,
                   wxString::FromUTF8(AV_STRINGIFY(LIBAVUTIL_VERSION)).c_str());
 
    int avcverdiff = (avcver >> 16 & 0xFF) - int(LIBAVCODEC_VERSION_MAJOR);
@@ -1097,12 +948,6 @@
       return false;
    }
 
-#if defined(DISABLE_DYNAMIC_LOADING_FFMPEG) && (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 69, 0))
-   av_register_protocol(&ufile_protocol);
-#else
-   av_register_protocol2(&ufile_protocol, sizeof(ufile_protocol));
-#endif
-
    return true;
 }
 
--- a/src/FFmpeg.h
+++ b/src/FFmpeg.h
@@ -41,28 +41,81 @@
    #include <libavutil/fifo.h>
    #include <libavutil/mathematics.h>
 
-   #if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 102, 0)
-   #define AVIOContext ByteIOContext
+   #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55, 45, 101)
+   #define av_frame_alloc avcodec_alloc_frame
+   #define av_frame_free avcodec_free_frame
    #endif
 
-   #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(52, 94, 1)
-   #define AVSampleFormat SampleFormat
+   #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(54, 59, 100)
+   #define avcodec_free_frame av_free
    #endif
 
-   #if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 120, 0)
-   #define CodecType AVMediaType
-   #define CODEC_TYPE_UNKNOWN    AVMEDIA_TYPE_UNKNOWN
-   #define CODEC_TYPE_VIDEO      AVMEDIA_TYPE_VIDEO
-   #define CODEC_TYPE_AUDIO      AVMEDIA_TYPE_AUDIO
-   #define CODEC_TYPE_DATA       AVMEDIA_TYPE_DATA
-   #define CODEC_TYPE_SUBTITLE   AVMEDIA_TYPE_SUBTITLE
-   #define CODEC_TYPE_ATTACHMENT AVMEDIA_TYPE_ATTACHMENT
-   #define CODEC_TYPE_NB         AVMEDIA_TYPE_NB
+   #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(54, 51, 100)
+   #define AVCodecID CodecID
+   #define AV_CODEC_ID_AAC CODEC_ID_AAC
+   #define AV_CODEC_ID_AC CODEC_ID_AC
+   #define AV_CODEC_ID_AC3 CODEC_ID_AC3
+   #define AV_CODEC_ID_ADPCM CODEC_ID_ADPCM
+   #define AV_CODEC_ID_ADPCM_CT CODEC_ID_ADPCM_CT
+   #define AV_CODEC_ID_ADPCM_G726 CODEC_ID_ADPCM_G726
+   #define AV_CODEC_ID_ADPCM_IMA_QT CODEC_ID_ADPCM_IMA_QT
+   #define AV_CODEC_ID_ADPCM_IMA_WAV CODEC_ID_ADPCM_IMA_WAV
+   #define AV_CODEC_ID_ADPCM_MS CODEC_ID_ADPCM_MS
+   #define AV_CODEC_ID_ADPCM_SWF CODEC_ID_ADPCM_SWF
+   #define AV_CODEC_ID_ADPCM_YAMAHA CODEC_ID_ADPCM_YAMAHA
+   #define AV_CODEC_ID_ALAC CODEC_ID_ALAC
+   #define AV_CODEC_ID_AMR CODEC_ID_AMR
+   #define AV_CODEC_ID_AMR_NB CODEC_ID_AMR_NB
+   #define AV_CODEC_ID_AMR_WB CODEC_ID_AMR_WB
+   #define AV_CODEC_ID_ATRAC CODEC_ID_ATRAC
+   #define AV_CODEC_ID_ATRAC3 CODEC_ID_ATRAC3
+   #define AV_CODEC_ID_DTS CODEC_ID_DTS
+   #define AV_CODEC_ID_DVAUDIO CODEC_ID_DVAUDIO
+   #define AV_CODEC_ID_FLAC CODEC_ID_FLAC
+   #define AV_CODEC_ID_GSM CODEC_ID_GSM
+   #define AV_CODEC_ID_GSM_MS CODEC_ID_GSM_MS
+   #define AV_CODEC_ID_IMC CODEC_ID_IMC
+   #define AV_CODEC_ID_MACE CODEC_ID_MACE
+   #define AV_CODEC_ID_MACE3 CODEC_ID_MACE3
+   #define AV_CODEC_ID_MACE6 CODEC_ID_MACE6
+   #define AV_CODEC_ID_MP CODEC_ID_MP
+   #define AV_CODEC_ID_MP2 CODEC_ID_MP2
+   #define AV_CODEC_ID_MP3 CODEC_ID_MP3
+   #define AV_CODEC_ID_NELLYMOSER CODEC_ID_NELLYMOSER
+   #define AV_CODEC_ID_NONE CODEC_ID_NONE
+   #define AV_CODEC_ID_PCM CODEC_ID_PCM
+   #define AV_CODEC_ID_PCM_ALAW CODEC_ID_PCM_ALAW
+   #define AV_CODEC_ID_PCM_MULAW CODEC_ID_PCM_MULAW
+   #define AV_CODEC_ID_PCM_S16BE CODEC_ID_PCM_S16BE
+   #define AV_CODEC_ID_PCM_S16LE CODEC_ID_PCM_S16LE
+   #define AV_CODEC_ID_PCM_S24BE CODEC_ID_PCM_S24BE
+   #define AV_CODEC_ID_PCM_S24LE CODEC_ID_PCM_S24LE
+   #define AV_CODEC_ID_PCM_S32BE CODEC_ID_PCM_S32BE
+   #define AV_CODEC_ID_PCM_S32LE CODEC_ID_PCM_S32LE
+   #define AV_CODEC_ID_PCM_S8 CODEC_ID_PCM_S8
+   #define AV_CODEC_ID_PCM_U8 CODEC_ID_PCM_U8
+   #define AV_CODEC_ID_QCELP CODEC_ID_QCELP
+   #define AV_CODEC_ID_QDM CODEC_ID_QDM
+   #define AV_CODEC_ID_QDM2 CODEC_ID_QDM2
+   #define AV_CODEC_ID_ROQ CODEC_ID_ROQ
+   #define AV_CODEC_ID_ROQ_DPCM CODEC_ID_ROQ_DPCM
+   #define AV_CODEC_ID_SONIC CODEC_ID_SONIC
+   #define AV_CODEC_ID_SONIC_LS CODEC_ID_SONIC_LS
+   #define AV_CODEC_ID_TRUESPEECH CODEC_ID_TRUESPEECH
+   #define AV_CODEC_ID_VORBIS CODEC_ID_VORBIS
+   #define AV_CODEC_ID_VOXWARE CODEC_ID_VOXWARE
+   #define AV_CODEC_ID_WMAPRO CODEC_ID_WMAPRO
+   #define AV_CODEC_ID_WMAV CODEC_ID_WMAV
+   #define AV_CODEC_ID_WMAV1 CODEC_ID_WMAV1
+   #define AV_CODEC_ID_WMAV2 CODEC_ID_WMAV2
+   #define AV_CODEC_ID_WMAVOICE CODEC_ID_WMAVOICE
    #endif
 
-   #ifndef PKT_FLAG_KEY
-   #define PKT_FLAG_KEY          AV_PKT_FLAG_KEY
-   #endif  
+   #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(54, 8, 100)
+   inline bool av_codec_is_encoder(AVCodec *codec) {
+      return codec != NULL && (codec->encode != NULL || codec->encode2 != NULL);
+   }
+   #endif
 }
 #endif
 
@@ -74,10 +127,10 @@
 #include <wx/log.h>			// for wxLogNull
 #include <wx/msgdlg.h>		// for wxMessageBox
 #include <wx/utils.h>
-#include "../widgets/LinkingHtmlWindow.h"
+#include "widgets/LinkingHtmlWindow.h"
 #include "FileDialog.h"
 #include "ShuttleGui.h"
-#include "../Prefs.h"
+#include "Prefs.h"
 #include <wx/checkbox.h>
 #include <wx/textctrl.h>
 // needed for sampleCount
@@ -331,6 +384,7 @@
 
 int ufile_fopen(AVIOContext **s, const wxString & name, int flags);
 int ufile_fopen_input(AVFormatContext **ic_ptr, wxString & name);
+int ufile_close(AVIOContext *pb);
 
 typedef struct _streamContext
 {
@@ -353,7 +407,7 @@
    int                  m_initialchannels;               // number of channels allocated when we begin the importing. Assumes that number of channels doesn't change on the fly.
 
    int                  m_samplesize;                    // input sample size in bytes
-   SampleFormat         m_samplefmt;                     // input sample format
+   AVSampleFormat       m_samplefmt;                     // input sample format
 
    int                  m_osamplesize;                   // output sample size in bytes
    sampleFormat         m_osamplefmt;                    // output sample format
@@ -368,18 +422,7 @@
 
 int import_ffmpeg_decode_frame(streamContext *sc, bool flushing);
 
-#if defined(DISABLE_DYNAMIC_LOADING_FFMPEG)
-   // Use the preprocessor to rename old function names instead of checking the
-   // function names with FFMPEG_INITALT when loading the library.
-
-   #if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 60, 0)
-   #define av_match_ext match_ext
-   #endif
-
-   #if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
-   #define av_guess_format guess_format
-   #endif
-#else
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG)
 extern "C" {
    // A little explanation of what's going on here.
    //
@@ -510,15 +553,10 @@
       (void),
       ()
    );
-   FFMPEG_FUNCTION_NO_RETURN(
-      avcodec_init,
-      (void),
-      ()
-   );
    FFMPEG_FUNCTION_WITH_RETURN(
       AVCodec*,
       avcodec_find_encoder,
-      (enum CodecID id),
+      (enum AVCodecID id),
       (id)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
@@ -530,46 +568,32 @@
    FFMPEG_FUNCTION_WITH_RETURN(
       AVCodec*,
       avcodec_find_decoder,
-      (enum CodecID id),
+      (enum AVCodecID id),
       (id)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       unsigned int,
       av_codec_get_tag,
-      (const struct AVCodecTag * const *tags, enum CodecID id),
+      (const struct AVCodecTag * const *tags, enum AVCodecID id),
       (tags, id)
    );
-   FFMPEG_FUNCTION_NO_RETURN(
-      avcodec_get_context_defaults,
-      (AVCodecContext *s),
-      (s)
-   );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      avcodec_open,
-      (AVCodecContext *avctx, AVCodec *codec),
-      (avctx, codec);
+      avcodec_open2,
+      (AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options),
+      (avctx, codec, options);
    );
-#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      avcodec_decode_audio3,
-      (AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt),
-      (avctx, samples, frame_size_ptr, avpkt)
+      avcodec_decode_audio4,
+      (AVCodecContext *avctx, AVFrame *frame, int *got_output, const AVPacket *avpkt),
+      (avctx, frame, got_output, avpkt)
    );
-#else
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      avcodec_decode_audio2,
-      (AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, const uint8_t *buf, int buf_size),
-      (avctx, samples, frame_size_ptr, buf, buf_size)
-   );
-#endif
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      avcodec_encode_audio,
-      (AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples),
-      (avctx, buf, buf_size, samples)
+      avcodec_encode_audio2,
+      (AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_output),
+      (avctx, pkt, frame, got_output)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
@@ -584,15 +608,15 @@
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_get_bits_per_sample_format,
-      (enum SampleFormat sample_fmt),
+      av_get_bytes_per_sample,
+      (enum AVSampleFormat sample_fmt),
       (sample_fmt)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_get_bits_per_sample_fmt,
-      (enum AVSampleFormat sample_fmt),
-      (sample_fmt)
+      avcodec_fill_audio_frame,
+      (AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align),
+      (frame, nb_channels, sample_fmt, buf, buf_size, align)
    );
 
    //
@@ -604,32 +628,11 @@
       (void),
       ()
    );
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(53, 0, 0)
-   FFMPEG_FUNCTION_WITH_RETURN(
-      void*,
-      av_fast_realloc,
-      (void *ptr, unsigned int *size, unsigned int min_size),
-      (ptr, size, min_size)
-   );
-#else
-   FFMPEG_FUNCTION_WITH_RETURN(
-      void*,
-      av_fast_realloc,
-      (void *ptr, unsigned int *size, size_t min_size),
-      (ptr, size, min_size)
-   );
-#endif
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_open_input_stream,
-      (AVFormatContext **ic_ptr, AVIOContext *pb, const char *filename, AVInputFormat *fmt, AVFormatParameters *ap),
-      (ic_ptr, pb, filename, fmt, ap)
-   );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      get_buffer,
-      (AVIOContext *s, unsigned char *buf, int size),
-      (s, buf, size)
+      avformat_open_input,
+      (AVFormatContext **ic_ptr, const char *filename, AVInputFormat *fmt, AVDictionary **options),
+      (ic_ptr, filename, fmt, options)
    );
    FFMPEG_FUNCTION_NO_RETURN(
       av_register_all,
@@ -638,15 +641,9 @@
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_register_protocol,
-      (URLProtocol *protocol),
-      (protocol)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_find_stream_info,
-      (AVFormatContext *ic),
-      (ic)
+      avformat_find_stream_info,
+      (AVFormatContext *ic, AVDictionary **options),
+      (ic, options)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
@@ -661,21 +658,15 @@
       (s, stream_index, timestamp, flags)
    );
    FFMPEG_FUNCTION_NO_RETURN(
-      av_close_input_file,
-      (AVFormatContext *s),
+      avformat_close_input,
+      (AVFormatContext **s),
       (s)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_write_header,
-      (AVFormatContext *s),
-      (s)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      AVInputFormat*,
-      av_iformat_next,
-      (AVInputFormat *f),
-      (f)
+      avformat_write_header,
+      (AVFormatContext *s, AVDictionary **options),
+      (s, options)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       AVOutputFormat*,
@@ -686,68 +677,14 @@
    FFMPEG_FUNCTION_WITH_RETURN(
       AVCodec*,
       av_codec_next,
-      (AVCodec *c),
+      (const AVCodec *c),
       (c)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_set_parameters,
-      (AVFormatContext *s, AVFormatParameters *ap),
-      (s, ap)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_open_protocol,
-      (URLContext **puc, struct URLProtocol *up, const char *filename, int flags),
-      (puc, up, filename, flags)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_open,
-      (URLContext **puc, const char *filename, int flags),
-      (puc, filename, flags)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_fdopen,
-      (AVIOContext **s, URLContext *h),
-      (s, h)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_close,
-      (URLContext *h),
-      (h)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_fopen,
-      (AVIOContext **s, const char *filename, int flags),
-      (s, filename, flags)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int64_t,
-      url_fseek,
-      (AVIOContext *s, int64_t offset, int whence),
-      (s, offset, whence)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      url_fclose,
-      (AVIOContext *s),
-      (s)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int64_t,
-      url_fsize,
-      (AVIOContext *s),
-      (s)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
       AVStream*,
-      av_new_stream,
-      (AVFormatContext *s, int id),
-      (s, id)
+      avformat_new_stream,
+      (AVFormatContext *s, const AVCodec *c),
+      (s, c)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       AVFormatContext*,
@@ -763,12 +700,6 @@
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_match_ext,
-      (const char *filename, const char *extensions),
-      (filename, extensions)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
       av_write_trailer,
       (AVFormatContext *s),
       (s)
@@ -801,21 +732,12 @@
       (AVFifoBuffer *f),
       (f)
    );
-#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(51, 0, 0)
-   FFMPEG_FUNCTION_WITH_RETURN(
-      void*,
-      av_malloc,
-      (unsigned int size),
-      (size)
-   );
-#else
    FFMPEG_FUNCTION_WITH_RETURN(
       void*,
       av_malloc,
       (size_t size),
       (size)
    );
-#endif
    FFMPEG_FUNCTION_NO_RETURN(
       av_freep,
       (void *ptr),
@@ -827,16 +749,11 @@
       (int64_t a, AVRational bq, AVRational cq),
       (a, bq, cq)
    );
-
-#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(52, 31, 0)
    FFMPEG_FUNCTION_NO_RETURN(
       av_free_packet,
       (AVPacket *pkt),
       (pkt)
    );
-#endif
-
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       AVFifoBuffer*,
       av_fifo_alloc,
@@ -849,20 +766,6 @@
       (AVFifoBuffer *f, void *buf, int buf_size, void (*func)(void*, void*, int)),
       (f, buf, buf_size, func)
    );
-#else
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_fifo_init,
-      (AVFifoBuffer *f, unsigned int size),
-      (f, size)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_fifo_generic_read,
-      (AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest),
-      (f, buf_size, func, dest)
-   );
-#endif
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
       av_fifo_realloc2,
@@ -870,46 +773,57 @@
       (f, size)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
-      AVMetadataTag *,
-      av_metadata_get,
-      (AVMetadata *m, const char *key, const AVMetadataTag *prev, int flags),
+      AVDictionaryEntry *,
+      av_dict_get,
+      (AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags),
       (m, key, prev, flags)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_metadata_set,
-      (AVMetadata **pm, const char *key, const char *value),
-      (pm, key, value)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      av_metadata_set2,
-      (AVMetadata **pm, const char *key, const char *value, int flags),
+      av_dict_set,
+      (AVDictionary **pm, const char *key, const char *value, int flags),
       (pm, key, value, flags)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
-      int,
-      avio_read,
-      (AVIOContext *s, unsigned char *buf, int size),
-      (s, buf, size)
+      int64_t,
+      avio_size,
+      (AVIOContext *s),
+      (s)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
-      int64_t,
-      avio_seek,
-      (AVIOContext *s, int64_t offset, int whence),
-      (s, offset, whence)
+      AVIOContext *,
+      avio_alloc_context,
+      (unsigned char *buffer,
+                  int buffer_size,
+                  int write_flag,
+                  void *opaque,
+                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
+                  int64_t (*seek)(void *opaque, int64_t offset, int whence)),
+      (buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      avio_close,
-      (AVIOContext *s),
-      (s)
+      av_codec_is_encoder,
+      (const AVCodec *codec),
+      (codec)
+   );
+   FFMPEG_FUNCTION_WITH_RETURN(
+      AVFrame*,
+      av_frame_alloc,
+      (void),
+      ()
+   );
+   FFMPEG_FUNCTION_NO_RETURN(
+      av_frame_free,
+      (AVFrame **frame),
+      (frame)
    );
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      av_register_protocol2,
-      (URLProtocol *protocol, int size),
-      (protocol, size)
+      av_samples_get_buffer_size,
+      (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align),
+      (linesize, nb_channels, nb_samples, sample_fmt, align)
    );
 };
 #endif
--- a/src/export/ExportFFmpeg.cpp
+++ b/src/export/ExportFFmpeg.cpp
@@ -12,8 +12,8 @@
 ******************************************************************//**
 
 \class ExportFFmpeg
-\brief Controlling class for FFmpeg exporting.  Creates the options 
-dialog of the appropriate type, adds tags and invokes the export 
+\brief Controlling class for FFmpeg exporting.  Creates the options
+dialog of the appropriate type, adds tags and invokes the export
 function.
 
 *//*******************************************************************/
@@ -49,6 +49,10 @@
 
 #include "ExportFFmpegDialogs.h"
 
+#if defined(WIN32)
+#define snprintf _snprintf
+#endif
+
 #if defined(USE_FFMPEG)
 
 extern FFmpegLibs *FFmpegLibsInst;
@@ -97,14 +101,14 @@
 
    /// Format intialization
    bool Init(const char *shortname, AudacityProject *project, Tags *metadata, int subformat);
-   
+
    /// Codec intialization
    bool InitCodecs(AudacityProject *project);
 
    /// Writes metadata
    bool AddTags(Tags *metadata);
 
-  /// Sets individual metadata values
+   /// Sets individual metadata values
    void SetMetadata(Tags *tags, const char *name, const wxChar *tag);
 
    /// Encodes audio
@@ -147,17 +151,12 @@
 
    AVFormatContext *	mEncFormatCtx;			   // libavformat's context for our output file
    AVOutputFormat  *	mEncFormatDesc;			// describes our output file to libavformat
-
+   int               default_frame_size;
    AVStream        *	mEncAudioStream;			// the output audio stream (may remain NULL)
    AVCodecContext  *	mEncAudioCodecCtx;		// the encoder for the output audio stream
-   uint8_t         *	mEncAudioEncodedBuf;		// buffer to hold frames encoded by the encoder
-   int			      mEncAudioEncodedBufSiz;		
    AVFifoBuffer	 * mEncAudioFifo;				// FIFO to write incoming audio samples into
    uint8_t         *	mEncAudioFifoOutBuf;		// buffer to read _out_ of the FIFO into
-
-#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(50, 0, 0)
-   AVFifoBuffer      mEncAudioFifoBuffer;    // FIFO to write incoming audio samples into
-#endif
+   int               mEncAudioFifoOutBufSiz;
 
    wxString          mName;
 
@@ -175,14 +174,9 @@
    mEncFormatDesc = NULL;			// describes our output file to libavformat
    mEncAudioStream = NULL;			// the output audio stream (may remain NULL)
    mEncAudioCodecCtx = NULL;		// the encoder for the output audio stream
-   mEncAudioEncodedBuf = NULL;	// buffer to hold frames encoded by the encoder
    #define MAX_AUDIO_PACKET_SIZE (128 * 1024)
-   mEncAudioEncodedBufSiz = 4*MAX_AUDIO_PACKET_SIZE;
    mEncAudioFifoOutBuf = NULL;	// buffer to read _out_ of the FIFO into
-   
-#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(50, 0, 0)
-   mEncAudioFifo = &mEncAudioFifoBuffer;
-#endif
+   mEncAudioFifoOutBufSiz = 0;
 
    mSampleRate = 0;
    mSupportsUTF8 = true;
@@ -265,8 +259,6 @@
 
    av_log_set_callback(av_log_wx_callback);
 
-   AVFormatParameters	fpOutFile;
-
    // See if libavformat has modules that can write our output format. If so, mEncFormatDesc
    // will describe the functions used to write the format (used internally by libavformat)
    // and the default video/audio codecs that the format uses.
@@ -286,39 +278,26 @@
    // Initialise the output format context.
    mEncFormatCtx->oformat = mEncFormatDesc;
    memcpy(mEncFormatCtx->filename, OSINPUT(mName), strlen(OSINPUT(mName))+1);
-   
+
    // At the moment Audacity can export only one audio stream
-   if ((mEncAudioStream = av_new_stream(mEncFormatCtx, 1)) == NULL)
+   if ((mEncAudioStream = avformat_new_stream(mEncFormatCtx, NULL)) == NULL)
    {
       wxLogError(wxT("FFmpeg : ERROR - Can't add audio stream to output file \"%s\"."), mName.c_str());
       return false;
    }
 
    mEncAudioStream->id = 0;
-   mEncFormatCtx->timestamp = 0;
 
    // Open the output file.
    if (!(mEncFormatDesc->flags & AVFMT_NOFILE))
    {
-      if ((err = ufile_fopen(&mEncFormatCtx->pb, mName, URL_WRONLY)) < 0)
+      if ((err = ufile_fopen(&mEncFormatCtx->pb, mName, AVIO_FLAG_WRITE)) < 0)
       {
          wxLogError(wxT("FFmpeg : ERROR - Can't open output file \"%s\" to write. Error code is %d."), mName.c_str(),err);
          return false;
       }
    }
 
-   // Set default parameters on the format context.
-   memset(&fpOutFile, 0, sizeof(AVFormatParameters));
-   if ((err = av_set_parameters(mEncFormatCtx, &fpOutFile)) < 0)
-   {
-      wxLogError(wxT("FFmpeg : ERROR - Can't set output parameters for output file \"%s\". Error code is %d."), mName.c_str(),err);
-      return false;
-   }
-
-   // I have no idea what is this
-   mEncFormatCtx->preload   = (int)(0.5 * AV_TIME_BASE);
-   mEncFormatCtx->max_delay = (int)(0.7 * AV_TIME_BASE);
-
    // Open the audio stream's codec and initialise any stream related data.
    if (!InitCodecs(project))
       return false;
@@ -334,7 +313,7 @@
    }
 
    // Write headers to the output file.
-   if ((err = av_write_header(mEncFormatCtx)) < 0)
+   if ((err = avformat_write_header(mEncFormatCtx, NULL)) < 0)
    {
       wxLogError(wxT("FFmpeg : ERROR - Can't write headers to output file \"%s\". Error code is %d."), mName.c_str(),err);
 
@@ -352,16 +331,23 @@
    return false;
 }
 
+static int set_dict_int(AVDictionary **dict, const char *key, int val)
+{
+   char val_str[256];
+   snprintf(val_str, sizeof(val_str), "%d", val);
+   return av_dict_set(dict, key, val_str, 0);
+}
+
 bool ExportFFmpeg::InitCodecs(AudacityProject *project)
 {
    AVCodec *	codec = NULL;
+   AVDictionary *options = NULL;
 
    // Configure the audio stream's codec context.
    mEncAudioCodecCtx = mEncAudioStream->codec;
-  
-   avcodec_get_context_defaults(mEncAudioCodecCtx);
+
    mEncAudioCodecCtx->codec_id = ExportFFmpegOptions::fmts[mSubFormat].codecid;
-   mEncAudioCodecCtx->codec_type = CODEC_TYPE_AUDIO;
+   mEncAudioCodecCtx->codec_type = AVMEDIA_TYPE_AUDIO;
    mEncAudioCodecCtx->codec_tag = av_codec_get_tag((const AVCodecTag **)mEncFormatCtx->oformat->codec_tag,mEncAudioCodecCtx->codec_id);
    mSampleRate = (int)project->GetRate();
    mEncAudioCodecCtx->global_quality = -99999; //quality mode is off by default;
@@ -399,10 +385,9 @@
       mEncAudioCodecCtx->bit_rate = gPrefs->Read(wxT("/FileFormats/WMABitRate"), 198000);
       if (!CheckSampleRate(mSampleRate,ExportFFmpegWMAOptions::iWMASampleRates[0], ExportFFmpegWMAOptions::iWMASampleRates[4], &ExportFFmpegWMAOptions::iWMASampleRates[0]))
          mSampleRate = AskResample(mEncAudioCodecCtx->bit_rate,mSampleRate, ExportFFmpegWMAOptions::iWMASampleRates[0], ExportFFmpegWMAOptions::iWMASampleRates[4], &ExportFFmpegWMAOptions::iWMASampleRates[0]);
-      mEncAudioCodecCtx->flags2 |= CODEC_FLAG2_BIT_RESERVOIR | 0x0004;
       break;
    case FMT_OTHER:
-      av_metadata_set2(&mEncAudioStream->metadata, "language", gPrefs->Read(wxT("/FileFormats/FFmpegLanguage"),wxT("")).ToUTF8(), 0);
+      av_dict_set(&mEncAudioStream->metadata, "language", gPrefs->Read(wxT("/FileFormats/FFmpegLanguage"),wxT("")).ToUTF8(), 0);
       mEncAudioCodecCtx->sample_rate = gPrefs->Read(wxT("/FileFormats/FFmpegSampleRate"),(long)0);
       if (mEncAudioCodecCtx->sample_rate != 0) mSampleRate = mEncAudioCodecCtx->sample_rate;
       mEncAudioCodecCtx->bit_rate = gPrefs->Read(wxT("/FileFormats/FFmpegBitRate"), (long)0);
@@ -410,22 +395,24 @@
       mEncAudioCodecCtx->global_quality = gPrefs->Read(wxT("/FileFormats/FFmpegQuality"),(long)-99999);
       mEncAudioCodecCtx->cutoff = gPrefs->Read(wxT("/FileFormats/FFmpegCutOff"),(long)0);
       mEncAudioCodecCtx->flags2 = 0;
-      if (gPrefs->Read(wxT("/FileFormats/FFmpegBitReservoir"),true)) mEncAudioCodecCtx->flags2 |= CODEC_FLAG2_BIT_RESERVOIR;
+      if (gPrefs->Read(wxT("/FileFormats/FFmpegBitReservoir"),true))
+         av_dict_set(&options, "reservoir", "1", 0);
       if (gPrefs->Read(wxT("/FileFormats/FFmpegVariableBlockLen"),true)) mEncAudioCodecCtx->flags2 |= 0x0004; //WMA only?
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(53, 0, 0)
-      mEncAudioCodecCtx->use_lpc = gPrefs->Read(wxT("/FileFormats/FFmpegUseLPC"),true);
-#endif
       mEncAudioCodecCtx->compression_level = gPrefs->Read(wxT("/FileFormats/FFmpegCompLevel"),-1);
       mEncAudioCodecCtx->frame_size = gPrefs->Read(wxT("/FileFormats/FFmpegFrameSize"),(long)0);
-      mEncAudioCodecCtx->lpc_coeff_precision = gPrefs->Read(wxT("/FileFormats/FFmpegLPCCoefPrec"),(long)0);
-      mEncAudioCodecCtx->min_prediction_order = gPrefs->Read(wxT("/FileFormats/FFmpegMinPredOrder"),(long)-1);
-      mEncAudioCodecCtx->max_prediction_order = gPrefs->Read(wxT("/FileFormats/FFmpegMaxPredOrder"),(long)-1);
-      mEncAudioCodecCtx->min_partition_order = gPrefs->Read(wxT("/FileFormats/FFmpegMinPartOrder"),(long)-1);
-      mEncAudioCodecCtx->max_partition_order = gPrefs->Read(wxT("/FileFormats/FFmpegMaxPartOrder"),(long)-1);
-      mEncAudioCodecCtx->prediction_order_method = gPrefs->Read(wxT("/FileFormats/FFmpegPredOrderMethod"),(long)0);
-      mEncFormatCtx->mux_rate = gPrefs->Read(wxT("/FileFormats/FFmpegMuxRate"),(long)0);
+
+//FIXME The list of supported options for the seleced encoder should be extracted instead of a few hardcoded
+      set_dict_int(&options, "lpc_coeff_precision",     gPrefs->Read(wxT("/FileFormats/FFmpegLPCCoefPrec"),(long)0));
+      set_dict_int(&options, "min_prediction_order",    gPrefs->Read(wxT("/FileFormats/FFmpegMinPredOrder"),(long)-1));
+      set_dict_int(&options, "max_prediction_order",    gPrefs->Read(wxT("/FileFormats/FFmpegMaxPredOrder"),(long)-1));
+      set_dict_int(&options, "min_partition_order",     gPrefs->Read(wxT("/FileFormats/FFmpegMinPartOrder"),(long)-1));
+      set_dict_int(&options, "max_partition_order",     gPrefs->Read(wxT("/FileFormats/FFmpegMaxPartOrder"),(long)-1));
+      set_dict_int(&options, "prediction_order_method", gPrefs->Read(wxT("/FileFormats/FFmpegPredOrderMethod"),(long)0));
+      set_dict_int(&options, "muxrate",                 gPrefs->Read(wxT("/FileFormats/FFmpegMuxRate"),(long)0));
       mEncFormatCtx->packet_size = gPrefs->Read(wxT("/FileFormats/FFmpegPacketSize"),(long)0);
-      mEncAudioCodecCtx->codec_id = (CodecID)gPrefs->Read(wxT("/FileFormats/FFmpegCodec"), mEncFormatDesc->audio_codec);
+      codec = avcodec_find_encoder_by_name(gPrefs->Read(wxT("/FileFormats/FFmpegCodec")).ToUTF8());
+      if (!codec)
+         mEncAudioCodecCtx->codec_id = mEncFormatDesc->audio_codec;
       break;
    default:
       return false;
@@ -438,16 +425,16 @@
    {
       mEncAudioCodecCtx->flags |= CODEC_FLAG_QSCALE;
    }
-   else mEncAudioCodecCtx->global_quality = -99999;
-   this->mEncAudioStream->quality = mEncAudioCodecCtx->global_quality = mEncAudioCodecCtx->global_quality * FF_QP2LAMBDA;
+   else mEncAudioCodecCtx->global_quality = 0;
+   mEncAudioCodecCtx->global_quality = mEncAudioCodecCtx->global_quality * FF_QP2LAMBDA;
    mEncAudioCodecCtx->sample_rate = mSampleRate;
    mEncAudioCodecCtx->channels = mChannels;
    mEncAudioCodecCtx->time_base.num = 1;
    mEncAudioCodecCtx->time_base.den = mEncAudioCodecCtx->sample_rate;
-   mEncAudioCodecCtx->sample_fmt = SAMPLE_FMT_S16;
-   //mEncAudioCodecCtx->strict_std_compliance = FF_COMPLIANCE_STRICT;
+   mEncAudioCodecCtx->sample_fmt = AV_SAMPLE_FMT_S16;
+   mEncAudioCodecCtx->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
 
-   if (mEncAudioCodecCtx->codec_id == CODEC_ID_AC3)
+   if (mEncAudioCodecCtx->codec_id == AV_CODEC_ID_AC3)
    {
       // As of Jan 4, 2011, the default AC3 encoder only accept SAMPLE_FMT_FLT samples.
       // But, currently, Audacity only supports SAMPLE_FMT_S16.  So, for now, look for the
@@ -469,6 +456,25 @@
       return false;
    }
 
+   if (codec->sample_fmts) {
+      for (int i=0; codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {
+         enum AVSampleFormat fmt = codec->sample_fmts[i];
+         if (   fmt == AV_SAMPLE_FMT_U8
+             || fmt == AV_SAMPLE_FMT_U8P
+             || fmt == AV_SAMPLE_FMT_S16
+             || fmt == AV_SAMPLE_FMT_S16P
+             || fmt == AV_SAMPLE_FMT_S32
+             || fmt == AV_SAMPLE_FMT_S32P
+             || fmt == AV_SAMPLE_FMT_FLT
+             || fmt == AV_SAMPLE_FMT_FLTP) {
+            mEncAudioCodecCtx->sample_fmt = fmt;
+         }
+         if (   fmt == AV_SAMPLE_FMT_S16
+             || fmt == AV_SAMPLE_FMT_S16P)
+            break;
+      }
+   }
+
    if (mEncFormatCtx->oformat->flags & AVFMT_GLOBALHEADER)
    {
       mEncAudioCodecCtx->flags |= CODEC_FLAG_GLOBAL_HEADER;
@@ -476,36 +482,26 @@
    }
 
    // Open the codec.
-   if (avcodec_open(mEncAudioCodecCtx, codec) < 0 || mEncAudioCodecCtx->frame_size == 0) 
+   if (avcodec_open2(mEncAudioCodecCtx, codec, &options) < 0)
    {
       wxLogError(wxT("FFmpeg : ERROR - Can't open audio codec 0x%x."),mEncAudioCodecCtx->codec_id);
       return false;
    }
- 
-   wxLogDebug(wxT("FFmpeg : Audio Output Codec Frame Size: %d samples."), mEncAudioCodecCtx->frame_size);
 
-   if ((mEncAudioCodecCtx->codec_id >= CODEC_ID_PCM_S16LE) && (mEncAudioCodecCtx->codec_id <= CODEC_ID_PCM_DVD))
-   {
-      mEncAudioEncodedBufSiz = FF_MIN_BUFFER_SIZE;
-   }
-   // Allocate a buffer for the encoder to store encoded audio frames into.
-   if ((mEncAudioEncodedBuf = (uint8_t*)av_malloc(mEncAudioEncodedBufSiz)) == NULL)
-   {
-      wxLogError(wxT("FFmpeg : ERROR - Can't allocate buffer to hold encoded audio."));
-      return false;
-   }
+   default_frame_size = mEncAudioCodecCtx->frame_size;
+   if (default_frame_size == 0)
+      default_frame_size = 1024; // arbitrary non zero value;
+
+   wxLogDebug(wxT("FFmpeg : Audio Output Codec Frame Size: %d samples."), mEncAudioCodecCtx->frame_size);
 
    // The encoder may require a minimum number of raw audio samples for each encoding but we can't
-   // guarantee we'll get this minimum each time an audio frame is decoded from the input file so 
+   // guarantee we'll get this minimum each time an audio frame is decoded from the input file so
    // we use a FIFO to store up incoming raw samples until we have enough for one call to the codec.
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    mEncAudioFifo = av_fifo_alloc(1024);
-#else
-   av_fifo_init(mEncAudioFifo, 1024);
-#endif
 
+   mEncAudioFifoOutBufSiz = 2*MAX_AUDIO_PACKET_SIZE;
    // Allocate a buffer to read OUT of the FIFO into. The FIFO maintains its own buffer internally.
-   if ((mEncAudioFifoOutBuf = (uint8_t*)av_malloc(2*MAX_AUDIO_PACKET_SIZE)) == NULL)
+   if ((mEncAudioFifoOutBuf = (uint8_t*)av_malloc(mEncAudioFifoOutBufSiz)) == NULL)
    {
       wxLogError(wxT("FFmpeg : ERROR - Can't allocate buffer to read into from audio FIFO."));
       return false;
@@ -514,6 +510,92 @@
    return true;
 }
 
+static int encode_audio(AVCodecContext *avctx, AVPacket *pkt, int16_t *audio_samples, int nb_samples)
+{
+   int i, ch, buffer_size, ret, got_output = 0;
+   void *samples = NULL;
+   AVFrame *frame = NULL;
+
+   if (audio_samples) {
+      frame = av_frame_alloc();
+      if (!frame)
+         return AVERROR(ENOMEM);
+
+      frame->nb_samples     = nb_samples;
+      frame->format         = avctx->sample_fmt;
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(54, 13, 0))
+      frame->channel_layout = avctx->channel_layout;
+#endif
+
+      buffer_size = av_samples_get_buffer_size(NULL, avctx->channels, frame->nb_samples,
+                                              avctx->sample_fmt, 0);
+      if (buffer_size < 0) {
+         wxLogError(wxT("FFmpeg : ERROR - Could not get sample buffer siz"));
+         return buffer_size;
+      }
+      samples = av_malloc(buffer_size);
+      if (!samples) {
+         wxLogError(wxT("FFmpeg : ERROR - Could not allocate bytes for samples buffer"));
+         return AVERROR(ENOMEM);
+      }
+      /* setup the data pointers in the AVFrame */
+      ret = avcodec_fill_audio_frame(frame, avctx->channels, avctx->sample_fmt,
+                                  (const uint8_t*)samples, buffer_size, 0);
+      if (ret < 0) {
+         wxLogError(wxT("FFmpeg : ERROR - Could not setup audio frame"));
+         return ret;
+      }
+
+      for (ch = 0; ch < avctx->channels; ch++) {
+         for (i = 0; i < frame->nb_samples; i++) {
+            switch(avctx->sample_fmt) {
+            case AV_SAMPLE_FMT_U8:
+               ((uint8_t*)(frame->data[0]))[ch + i*avctx->channels] = audio_samples[ch + i*avctx->channels]/258 + 128;
+               break;
+            case AV_SAMPLE_FMT_U8P:
+               ((uint8_t*)(frame->data[ch]))[i] = audio_samples[ch + i*avctx->channels]/258 + 128;
+               break;
+            case AV_SAMPLE_FMT_S16:
+               ((int16_t*)(frame->data[0]))[ch + i*avctx->channels] = audio_samples[ch + i*avctx->channels];
+               break;
+            case AV_SAMPLE_FMT_S16P:
+               ((int16_t*)(frame->data[ch]))[i] = audio_samples[ch + i*avctx->channels];
+               break;
+            case AV_SAMPLE_FMT_S32:
+               ((int32_t*)(frame->data[0]))[ch + i*avctx->channels] = audio_samples[ch + i*avctx->channels]<<16;
+               break;
+            case AV_SAMPLE_FMT_S32P:
+               ((int32_t*)(frame->data[ch]))[i] = audio_samples[ch + i*avctx->channels]<<16;
+               break;
+            case AV_SAMPLE_FMT_FLT:
+               ((float*)(frame->data[0]))[ch + i*avctx->channels] = audio_samples[ch + i*avctx->channels] / 32767.0;
+               break;
+            case AV_SAMPLE_FMT_FLTP:
+               ((float*)(frame->data[ch]))[i] = audio_samples[ch + i*avctx->channels] / 32767.;
+               break;
+            }
+         }
+      }
+   }
+   av_init_packet(pkt);
+   pkt->data = NULL; // packet data will be allocated by the encoder
+   pkt->size = 0;
+
+   ret = avcodec_encode_audio2(avctx, pkt, frame, &got_output);
+   if (ret < 0) {
+      wxLogError(wxT("FFmpeg : ERROR - encoding frame failed"));
+      return ret;
+   }
+
+   pkt->dts = pkt->pts = AV_NOPTS_VALUE; // we dont set frame.pts thus dont trust the AVPacket ts
+
+   av_frame_free(&frame);
+   av_freep(&samples);
+
+   return got_output;
+}
+
+
 bool ExportFFmpeg::Finalize()
 {
    int i, nEncodedBytes;
@@ -524,82 +606,75 @@
       AVPacket	pkt;
       int		nFifoBytes = av_fifo_size(mEncAudioFifo);	// any bytes left in audio FIFO?
 
+      av_init_packet(&pkt);
+
       nEncodedBytes = 0;
-      int		nAudioFrameSizeOut = mEncAudioCodecCtx->frame_size * mEncAudioCodecCtx->channels * sizeof(int16_t);
-      if (mEncAudioCodecCtx->frame_size == 1) nAudioFrameSizeOut = mEncAudioEncodedBufSiz;
+      int		nAudioFrameSizeOut = default_frame_size * mEncAudioCodecCtx->channels * sizeof(int16_t);
+
+      if (nAudioFrameSizeOut > mEncAudioFifoOutBufSiz || nFifoBytes > mEncAudioFifoOutBufSiz) {
+         wxLogError(wxT("FFmpeg : ERROR - Too much remaining data."));
+         return false;
+      }
 
       // Flush the audio FIFO first if necessary. It won't contain a _full_ audio frame because
-      // if it did we'd have pulled it from the FIFO during the last encodeAudioFrame() call - 
+      // if it did we'd have pulled it from the FIFO during the last encodeAudioFrame() call -
       // the encoder must support short/incomplete frames for this to work.
       if (nFifoBytes > 0)
       {
          // Fill audio buffer with zeroes. If codec tries to read the whole buffer,
          // it will just read silence. If not - who cares?
-         memset(mEncAudioFifoOutBuf,0,nAudioFrameSizeOut);
-         AVCodec *codec = mEncAudioCodecCtx->codec;
+         memset(mEncAudioFifoOutBuf,0,mEncAudioFifoOutBufSiz);
+         const AVCodec *codec = mEncAudioCodecCtx->codec;
 
          // We have an incomplete buffer of samples left.  Is it OK to encode it?
          // If codec supports CODEC_CAP_SMALL_LAST_FRAME, we can feed it with smaller frame
          // Or if codec is FLAC, feed it anyway (it doesn't have CODEC_CAP_SMALL_LAST_FRAME, but it works)
          // Or if frame_size is 1, then it's some kind of PCM codec, they don't have frames and will be fine with the samples
          // Or if user configured the exporter to pad with silence, then we'll send audio + silence as a frame.
-         if ((codec->capabilities & CODEC_CAP_SMALL_LAST_FRAME)
-            || codec->id == CODEC_ID_FLAC
-            || mEncAudioCodecCtx->frame_size == 1
+         if ((codec->capabilities & (CODEC_CAP_SMALL_LAST_FRAME|CODEC_CAP_VARIABLE_FRAME_SIZE))
+            || mEncAudioCodecCtx->frame_size <= 1
             || gPrefs->Read(wxT("/FileFormats/OverrideSmallLastFrame"), true)
             )
          {
-            int nFrameSizeTmp = mEncAudioCodecCtx->frame_size;
+            int frame_size = default_frame_size;
 
             // The last frame is going to contain a smaller than usual number of samples.
             // For codecs without CODEC_CAP_SMALL_LAST_FRAME use normal frame size
-            if (mEncAudioCodecCtx->frame_size != 1 && codec->capabilities & CODEC_CAP_SMALL_LAST_FRAME)
-               mEncAudioCodecCtx->frame_size = nFifoBytes / (mEncAudioCodecCtx->channels * sizeof(int16_t));
+            if (codec->capabilities & (CODEC_CAP_SMALL_LAST_FRAME|CODEC_CAP_VARIABLE_FRAME_SIZE))
+               frame_size = nFifoBytes / (mEncAudioCodecCtx->channels * sizeof(int16_t));
 
-            wxLogDebug(wxT("FFmpeg : Audio FIFO still contains %d bytes, writing %d sample frame ..."), 
-               nFifoBytes, mEncAudioCodecCtx->frame_size);
+            wxLogDebug(wxT("FFmpeg : Audio FIFO still contains %d bytes, writing %d sample frame ..."),
+               nFifoBytes, frame_size);
 
             // Pull the bytes out from the FIFO and feed them to the encoder.
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
             if (av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes, NULL) == 0)
-#else
-            if (av_fifo_generic_read(mEncAudioFifo, nFifoBytes, NULL, mEncAudioFifoOutBuf) == 0)
-#endif
             {
-               if (mEncAudioCodecCtx->frame_size != 1)
-                  nEncodedBytes = avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, (int16_t*)mEncAudioFifoOutBuf);
-               else
-                  nEncodedBytes = avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, nFifoBytes, (int16_t*)mEncAudioFifoOutBuf);
+               nEncodedBytes = encode_audio(mEncAudioCodecCtx, &pkt, (int16_t*)mEncAudioFifoOutBuf, frame_size);
             }
-
-            mEncAudioCodecCtx->frame_size = nFrameSizeTmp;		// restore the native frame size
          }
       }
 
       // Now flush the encoder.
       if (nEncodedBytes <= 0)
-         nEncodedBytes = avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, NULL);
+         nEncodedBytes = encode_audio(mEncAudioCodecCtx, &pkt, NULL, 0);
 
-      if (nEncodedBytes <= 0)			
+      if (nEncodedBytes <= 0)
          break;
 
-      // Okay, we got a final encoded frame we can write to the output file.
-      av_init_packet(&pkt);
-
       pkt.stream_index = mEncAudioStream->index;
-      pkt.data = mEncAudioEncodedBuf;
-      pkt.size = nEncodedBytes;
-      pkt.flags |= PKT_FLAG_KEY;
 
       // Set presentation time of frame (currently in the codec's timebase) in the stream timebase.
-      if(mEncAudioCodecCtx->coded_frame && mEncAudioCodecCtx->coded_frame->pts != int64_t(AV_NOPTS_VALUE))
-         pkt.pts = av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+      if(pkt.pts != int64_t(AV_NOPTS_VALUE))
+         pkt.pts = av_rescale_q(pkt.pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+      if(pkt.dts != int64_t(AV_NOPTS_VALUE))
+         pkt.dts = av_rescale_q(pkt.dts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
 
       if (av_interleaved_write_frame(mEncFormatCtx, &pkt) != 0)
       {
          wxLogError(wxT("FFmpeg : ERROR - Couldn't write last audio frame to output file."));
          break;
       }
+      av_free_packet(&pkt);
    }
 
    // Write any file trailers.
@@ -617,22 +692,17 @@
 
    // Close the output file if we created it.
    if (!(mEncFormatDesc->flags & AVFMT_NOFILE))
-      avio_close(mEncFormatCtx->pb);
+      ufile_close(mEncFormatCtx->pb);
 
    // Free any buffers or structures we allocated.
    av_free(mEncFormatCtx);
 
-   if (mEncAudioEncodedBuf != NULL)
-      av_free(mEncAudioEncodedBuf);
-
-   if (mEncAudioFifoOutBuf != NULL)
-      av_free(mEncAudioFifoOutBuf);
+   av_freep(&mEncAudioFifoOutBuf);
+   mEncAudioFifoOutBufSiz = 0;
 
    av_fifo_free(mEncAudioFifo);
 
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    mEncAudioFifo = NULL;
-#endif
 
    return true;
 }
@@ -642,8 +712,7 @@
    AVPacket	pkt;
    int		nBytesToWrite = 0;
    uint8_t *	pRawSamples = NULL;
-   int		nAudioFrameSizeOut = mEncAudioCodecCtx->frame_size * mEncAudioCodecCtx->channels * sizeof(int16_t);
-   if (mEncAudioCodecCtx->frame_size == 1) nAudioFrameSizeOut = mEncAudioEncodedBufSiz;
+   int		nAudioFrameSizeOut = default_frame_size * mEncAudioCodecCtx->channels * sizeof(int16_t);
    int      ret;
 
    nBytesToWrite = frameSize;
@@ -655,42 +724,46 @@
 
    wxASSERT(ret == nBytesToWrite);
 
+   if (nAudioFrameSizeOut > mEncAudioFifoOutBufSiz) {
+      wxLogError(wxT("FFmpeg : ERROR - nAudioFrameSizeOut too large."));
+      return false;
+   }
+
    // Read raw audio samples out of the FIFO in nAudioFrameSizeOut byte-sized groups to encode.
    while ((ret = av_fifo_size(mEncAudioFifo)) >= nAudioFrameSizeOut)
    {
-#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
       ret = av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut, NULL);
-#else
-      ret = av_fifo_generic_read(mEncAudioFifo, nAudioFrameSizeOut, NULL, mEncAudioFifoOutBuf);
-#endif
 
       av_init_packet(&pkt);
 
-      pkt.size = avcodec_encode_audio(mEncAudioCodecCtx, 
-         mEncAudioEncodedBuf, mEncAudioEncodedBufSiz,		// out
-         (int16_t*)mEncAudioFifoOutBuf);				// in
-      if (mEncAudioCodecCtx->frame_size == 1) { wxASSERT(pkt.size == mEncAudioEncodedBufSiz); }
-      if (pkt.size < 0)
+      int ret= encode_audio(mEncAudioCodecCtx,
+         &pkt,		// out
+         (int16_t*)mEncAudioFifoOutBuf,                         // in
+         default_frame_size);
+      if (ret < 0)
       {
          wxLogError(wxT("FFmpeg : ERROR - Can't encode audio frame."));
          return false;
       }
+      if (ret == 0)
+         continue;
 
       // Rescale from the codec time_base to the AVStream time_base.
-      if (mEncAudioCodecCtx->coded_frame && mEncAudioCodecCtx->coded_frame->pts != int64_t(AV_NOPTS_VALUE))
-         pkt.pts = av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+      if (pkt.pts != int64_t(AV_NOPTS_VALUE))
+         pkt.pts = av_rescale_q(pkt.pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+      if (pkt.dts != int64_t(AV_NOPTS_VALUE))
+         pkt.dts = av_rescale_q(pkt.dts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
       //wxLogDebug(wxT("FFmpeg : (%d) Writing audio frame with PTS: %lld."), mEncAudioCodecCtx->frame_number, pkt.pts);
 
       pkt.stream_index = mEncAudioStream->index;
-      pkt.data = mEncAudioEncodedBuf;
-      pkt.flags |= PKT_FLAG_KEY;
 
       // Write the encoded audio frame to the output file.
-      if ((ret = av_interleaved_write_frame(mEncFormatCtx, &pkt)) != 0)
+      if ((ret = av_interleaved_write_frame(mEncFormatCtx, &pkt)) < 0)
       {
          wxLogError(wxT("FFmpeg : ERROR - Failed to write audio frame to file."));
          return false;
       }
+      av_free_packet(&pkt);
    }
    return true;
 }
@@ -710,9 +783,9 @@
       wxLogError(wxT("Attempted to export %d channels, but max. channels = %d"),channels,ExportFFmpegOptions::fmts[mSubFormat].maxchannels);
       wxMessageBox(
          wxString::Format(
-               _("Attempted to export %d channels, but maximum number of channels for selected output format is %d"), 
-               channels, 
-               ExportFFmpegOptions::fmts[mSubFormat].maxchannels), 
+               _("Attempted to export %d channels, but maximum number of channels for selected output format is %d"),
+               channels,
+               ExportFFmpegOptions::fmts[mSubFormat].maxchannels),
             _("Error"));
       return false;
    }
@@ -721,7 +794,7 @@
    bool ret = true;
 
    if (mSubFormat >= FMT_LAST) return false;
-   
+
    wxString shortname(ExportFFmpegOptions::fmts[mSubFormat].shortname);
    if (mSubFormat == FMT_OTHER)
       shortname = gPrefs->Read(wxT("/FileFormats/FFmpegFormat"),wxT("matroska"));
@@ -805,7 +878,7 @@
    {
       wxString value = tags->GetTag(tag);
 
-      av_metadata_set2(&mEncFormatCtx->metadata, name, mSupportsUTF8 ? value.ToUTF8() : value.mb_str(), 0);
+      av_dict_set(&mEncFormatCtx->metadata, name, mSupportsUTF8 ? value.ToUTF8() : value.mb_str(), 0);
    }
 }
 
--- a/src/export/ExportFFmpegDialogs.cpp
+++ b/src/export/ExportFFmpegDialogs.cpp
@@ -163,8 +163,8 @@
    PopulateOrExchange(S);
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAC3Options::PopulateOrExchange(ShuttleGui & S)
 {
    S.StartHorizontalLay(wxEXPAND, 0);
@@ -173,7 +173,7 @@
       {
          S.StartTwoColumn();
          {
-            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/AC3BitRate"), 
+            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/AC3BitRate"),
                160000, mBitRateNames, mBitRateLabels);
          }
          S.EndTwoColumn();
@@ -192,8 +192,8 @@
    return;
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAC3Options::OnOK(wxCommandEvent& WXUNUSED(event))
 {
    ShuttleGui S(this, eIsSavingToPrefs);
@@ -221,8 +221,8 @@
    PopulateOrExchange(S);
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAACOptions::PopulateOrExchange(ShuttleGui & S)
 {
    S.StartStatic(_("AAC Export Setup"), 1);
@@ -245,8 +245,8 @@
    return;
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAACOptions::OnOK(wxCommandEvent& WXUNUSED(event))
 {
    ShuttleGui S(this, eIsSavingToPrefs);
@@ -286,8 +286,8 @@
    PopulateOrExchange(S);
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAMRNBOptions::PopulateOrExchange(ShuttleGui & S)
 {
    S.StartHorizontalLay(wxEXPAND, 0);
@@ -296,7 +296,7 @@
       {
          S.StartTwoColumn();
          {
-            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/AMRNBBitRate"), 
+            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/AMRNBBitRate"),
                12200, mBitRateNames, mBitRateLabels);
          }
          S.EndTwoColumn();
@@ -315,8 +315,8 @@
    return;
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegAMRNBOptions::OnOK(wxCommandEvent& WXUNUSED(event))
 {
    ShuttleGui S(this, eIsSavingToPrefs);
@@ -358,8 +358,8 @@
    PopulateOrExchange(S);
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegWMAOptions::PopulateOrExchange(ShuttleGui & S)
 {
    S.StartHorizontalLay(wxEXPAND, 0);
@@ -368,7 +368,7 @@
       {
          S.StartTwoColumn();
          {
-            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/WMABitRate"), 
+            S.TieChoice(_("Bit Rate:"), wxT("/FileFormats/WMABitRate"),
                96000, mBitRateNames, mBitRateLabels);
          }
          S.EndTwoColumn();
@@ -387,8 +387,8 @@
    return;
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegWMAOptions::OnOK(wxCommandEvent& WXUNUSED(event))
 {
    ShuttleGui S(this, eIsSavingToPrefs);
@@ -458,7 +458,7 @@
    {
       FFmpegPreset *preset = *iter;
       list->Add(*preset->mPresetName);
-   }   
+   }
    return list;
 }
 
@@ -542,7 +542,7 @@
          // Spin control
          case FEBitrateID:
          case FEQualityID:
-         case FESampleRateID:         
+         case FESampleRateID:
          case FECutoffID:
          case FEFrameSizeID:
          case FEBufSizeID:
@@ -625,7 +625,7 @@
          case FELPCCoeffsID:
          case FEMinPredID:
          case FEMaxPredID:
-         case FEMinPartOrderID:            
+         case FEMinPartOrderID:
          case FEMaxPartOrderID:
          case FEMuxRateID:
          case FEPacketSizeID:
@@ -793,302 +793,312 @@
 
 /// Format-codec compatibility list
 /// Must end with NULL entry
-CompatibilityEntry ExportFFmpegOptions::CompatibilityList[] = 
+CompatibilityEntry ExportFFmpegOptions::CompatibilityList[] =
 {
-   { wxT("adts"), CODEC_ID_AAC },
+   { wxT("adts"), AV_CODEC_ID_AAC },
 
-   { wxT("aiff"), CODEC_ID_PCM_S16BE },
-   { wxT("aiff"), CODEC_ID_PCM_S8 },
-   { wxT("aiff"), CODEC_ID_PCM_S24BE },
-   { wxT("aiff"), CODEC_ID_PCM_S32BE },
-   { wxT("aiff"), CODEC_ID_PCM_ALAW },
-   { wxT("aiff"), CODEC_ID_PCM_MULAW },
-   { wxT("aiff"), CODEC_ID_MACE3 },
-   { wxT("aiff"), CODEC_ID_MACE6 },
-   { wxT("aiff"), CODEC_ID_GSM },
-   { wxT("aiff"), CODEC_ID_ADPCM_G726 },
-   { wxT("aiff"), CODEC_ID_PCM_S16LE },
-   { wxT("aiff"), CODEC_ID_ADPCM_IMA_QT },
-   { wxT("aiff"), CODEC_ID_QDM2 },
-
-   { wxT("amr"), CODEC_ID_AMR_NB },
-   { wxT("amr"), CODEC_ID_AMR_WB },
-
-   { wxT("asf"), CODEC_ID_PCM_S16LE },
-   { wxT("asf"), CODEC_ID_PCM_U8 },
-   { wxT("asf"), CODEC_ID_PCM_S24LE },
-   { wxT("asf"), CODEC_ID_PCM_S32LE },
-   { wxT("asf"), CODEC_ID_ADPCM_MS },
-   { wxT("asf"), CODEC_ID_PCM_ALAW },
-   { wxT("asf"), CODEC_ID_PCM_MULAW },
-   { wxT("asf"), CODEC_ID_WMAVOICE },
-   { wxT("asf"), CODEC_ID_ADPCM_IMA_WAV },
-   { wxT("asf"), CODEC_ID_ADPCM_YAMAHA },
-   { wxT("asf"), CODEC_ID_TRUESPEECH },
-   { wxT("asf"), CODEC_ID_GSM_MS },
-   { wxT("asf"), CODEC_ID_ADPCM_G726 },
-   { wxT("asf"), CODEC_ID_MP2 },
-   { wxT("asf"), CODEC_ID_MP3 },
-   { wxT("asf"), CODEC_ID_VOXWARE },
-   { wxT("asf"), CODEC_ID_AAC },
-   { wxT("asf"), CODEC_ID_WMAV1 },
-   { wxT("asf"), CODEC_ID_WMAV2 },
-   { wxT("asf"), CODEC_ID_WMAPRO },
-   { wxT("asf"), CODEC_ID_ADPCM_CT },
-   { wxT("asf"), CODEC_ID_ATRAC3 },
-   { wxT("asf"), CODEC_ID_IMC },
-   { wxT("asf"), CODEC_ID_AC3 },
-   { wxT("asf"), CODEC_ID_DTS },
-   { wxT("asf"), CODEC_ID_SONIC },
-   { wxT("asf"), CODEC_ID_SONIC_LS },
-   { wxT("asf"), CODEC_ID_FLAC },
-   { wxT("asf"), CODEC_ID_ADPCM_SWF },
-   { wxT("asf"), CODEC_ID_VORBIS },
-
-   { wxT("au"), CODEC_ID_PCM_MULAW },
-   { wxT("au"), CODEC_ID_PCM_S8 },
-   { wxT("au"), CODEC_ID_PCM_S16BE },
-   { wxT("au"), CODEC_ID_PCM_ALAW },
-
-   { wxT("avi"), CODEC_ID_PCM_S16LE },
-   { wxT("avi"), CODEC_ID_PCM_U8 },
-   { wxT("avi"), CODEC_ID_PCM_S24LE },
-   { wxT("avi"), CODEC_ID_PCM_S32LE },
-   { wxT("avi"), CODEC_ID_ADPCM_MS },
-   { wxT("avi"), CODEC_ID_PCM_ALAW },
-   { wxT("avi"), CODEC_ID_PCM_MULAW },
-   { wxT("avi"), CODEC_ID_WMAVOICE },
-   { wxT("avi"), CODEC_ID_ADPCM_IMA_WAV },
-   { wxT("avi"), CODEC_ID_ADPCM_YAMAHA },
-   { wxT("avi"), CODEC_ID_TRUESPEECH },
-   { wxT("avi"), CODEC_ID_GSM_MS },
-   { wxT("avi"), CODEC_ID_ADPCM_G726 },
-   { wxT("avi"), CODEC_ID_MP2 },
-   { wxT("avi"), CODEC_ID_MP3 },
-   { wxT("avi"), CODEC_ID_VOXWARE },
-   { wxT("avi"), CODEC_ID_AAC },
-   { wxT("avi"), CODEC_ID_WMAV1 },
-   { wxT("avi"), CODEC_ID_WMAV2 },
-   { wxT("avi"), CODEC_ID_WMAPRO },
-   { wxT("avi"), CODEC_ID_ADPCM_CT },
-   { wxT("avi"), CODEC_ID_ATRAC3 },
-   { wxT("avi"), CODEC_ID_IMC },
-   { wxT("avi"), CODEC_ID_AC3 },
-   { wxT("avi"), CODEC_ID_DTS },
-   { wxT("avi"), CODEC_ID_SONIC },
-   { wxT("avi"), CODEC_ID_SONIC_LS },
-   { wxT("avi"), CODEC_ID_FLAC },
-   { wxT("avi"), CODEC_ID_ADPCM_SWF },
-   { wxT("avi"), CODEC_ID_VORBIS },
-
-   { wxT("crc"), CODEC_ID_NONE },
-
-   { wxT("dv"), CODEC_ID_PCM_S16LE },
-
-   { wxT("ffm"), CODEC_ID_NONE },
-
-   { wxT("flv"), CODEC_ID_MP3 },
-   { wxT("flv"), CODEC_ID_PCM_S8 },
-   { wxT("flv"), CODEC_ID_PCM_S16BE },
-   { wxT("flv"), CODEC_ID_PCM_S16LE },
-   { wxT("flv"), CODEC_ID_ADPCM_SWF },
-   { wxT("flv"), CODEC_ID_AAC },
-   { wxT("flv"), CODEC_ID_NELLYMOSER },
-
-   { wxT("framecrc"), CODEC_ID_NONE },
-
-   { wxT("gxf"), CODEC_ID_PCM_S16LE },
-
-   { wxT("matroska"), CODEC_ID_PCM_S16LE },
-   { wxT("matroska"), CODEC_ID_PCM_U8 },
-   { wxT("matroska"), CODEC_ID_PCM_S24LE },
-   { wxT("matroska"), CODEC_ID_PCM_S32LE },
-   { wxT("matroska"), CODEC_ID_ADPCM_MS },
-   { wxT("matroska"), CODEC_ID_PCM_ALAW },
-   { wxT("matroska"), CODEC_ID_PCM_MULAW },
-   { wxT("matroska"), CODEC_ID_WMAVOICE },
-   { wxT("matroska"), CODEC_ID_ADPCM_IMA_WAV },
-   { wxT("matroska"), CODEC_ID_ADPCM_YAMAHA },
-   { wxT("matroska"), CODEC_ID_TRUESPEECH },
-   { wxT("matroska"), CODEC_ID_GSM_MS },
-   { wxT("matroska"), CODEC_ID_ADPCM_G726 },
-   { wxT("matroska"), CODEC_ID_MP2 },
-   { wxT("matroska"), CODEC_ID_MP3 },
-   { wxT("matroska"), CODEC_ID_VOXWARE },
-   { wxT("matroska"), CODEC_ID_AAC },
-   { wxT("matroska"), CODEC_ID_WMAV1 },
-   { wxT("matroska"), CODEC_ID_WMAV2 },
-   { wxT("matroska"), CODEC_ID_WMAPRO },
-   { wxT("matroska"), CODEC_ID_ADPCM_CT },
-   { wxT("matroska"), CODEC_ID_ATRAC3 },
-   { wxT("matroska"), CODEC_ID_IMC },
-   { wxT("matroska"), CODEC_ID_AC3 },
-   { wxT("matroska"), CODEC_ID_DTS },
-   { wxT("matroska"), CODEC_ID_SONIC },
-   { wxT("matroska"), CODEC_ID_SONIC_LS },
-   { wxT("matroska"), CODEC_ID_FLAC },
-   { wxT("matroska"), CODEC_ID_ADPCM_SWF },
-   { wxT("matroska"), CODEC_ID_VORBIS },
-
-   { wxT("mmf"), CODEC_ID_ADPCM_YAMAHA },
-
-   { wxT("mov"), CODEC_ID_PCM_S32BE }, //mov
-   { wxT("mov"), CODEC_ID_PCM_S32LE },
-   { wxT("mov"), CODEC_ID_PCM_S24BE },
-   { wxT("mov"), CODEC_ID_PCM_S24LE },
-   { wxT("mov"), CODEC_ID_PCM_S16BE },
-   { wxT("mov"), CODEC_ID_PCM_S16LE },
-   { wxT("mov"), CODEC_ID_PCM_S8 },
-   { wxT("mov"), CODEC_ID_PCM_U8 },
-   { wxT("mov"), CODEC_ID_PCM_MULAW },
-   { wxT("mov"), CODEC_ID_PCM_ALAW },
-   { wxT("mov"), CODEC_ID_ADPCM_IMA_QT },
-   { wxT("mov"), CODEC_ID_MACE3 },
-   { wxT("mov"), CODEC_ID_MACE6 },
-   { wxT("mov"), CODEC_ID_MP3 },
-   { wxT("mov"), CODEC_ID_AAC },
-   { wxT("mov"), CODEC_ID_AMR_NB },
-   { wxT("mov"), CODEC_ID_AMR_WB },
-   { wxT("mov"), CODEC_ID_GSM },
-   { wxT("mov"), CODEC_ID_ALAC },
-   { wxT("mov"), CODEC_ID_QCELP },
-   { wxT("mov"), CODEC_ID_QDM2 },
-   { wxT("mov"), CODEC_ID_DVAUDIO },
-   { wxT("mov"), CODEC_ID_WMAV2 },
-   { wxT("mov"), CODEC_ID_ALAC },
-
-   { wxT("mp4"), CODEC_ID_AAC },
-   { wxT("mp4"), CODEC_ID_QCELP },
-   { wxT("mp4"), CODEC_ID_MP3 },
-   { wxT("mp4"), CODEC_ID_VORBIS },
-
-   { wxT("psp"), CODEC_ID_AAC },
-   { wxT("psp"), CODEC_ID_QCELP },
-   { wxT("psp"), CODEC_ID_MP3 },
-   { wxT("psp"), CODEC_ID_VORBIS },
-
-   { wxT("ipod"), CODEC_ID_AAC },
-   { wxT("ipod"), CODEC_ID_QCELP },
-   { wxT("ipod"), CODEC_ID_MP3 },
-   { wxT("ipod"), CODEC_ID_VORBIS },
-
-   { wxT("3gp"), CODEC_ID_AAC },
-   { wxT("3gp"), CODEC_ID_AMR_NB },
-   { wxT("3gp"), CODEC_ID_AMR_WB },
-
-   { wxT("3g2"), CODEC_ID_AAC },
-   { wxT("3g2"), CODEC_ID_AMR_NB },
-   { wxT("3g2"), CODEC_ID_AMR_WB },
-
-   { wxT("mp3"), CODEC_ID_MP3 },
-
-   { wxT("mpeg"), CODEC_ID_AC3 },
-   { wxT("mpeg"), CODEC_ID_DTS },
-   { wxT("mpeg"), CODEC_ID_PCM_S16BE },
-   { wxT("mpeg"), CODEC_ID_MP2 },
-
-   { wxT("vcd"), CODEC_ID_AC3 },
-   { wxT("vcd"), CODEC_ID_DTS },
-   { wxT("vcd"), CODEC_ID_PCM_S16BE },
-   { wxT("vcd"), CODEC_ID_MP2 },
-
-   { wxT("vob"), CODEC_ID_AC3 },
-   { wxT("vob"), CODEC_ID_DTS },
-   { wxT("vob"), CODEC_ID_PCM_S16BE },
-   { wxT("vob"), CODEC_ID_MP2 },
-
-   { wxT("svcd"), CODEC_ID_AC3 },
-   { wxT("svcd"), CODEC_ID_DTS },
-   { wxT("svcd"), CODEC_ID_PCM_S16BE },
-   { wxT("svcd"), CODEC_ID_MP2 },
-
-   { wxT("dvd"), CODEC_ID_AC3 },
-   { wxT("dvd"), CODEC_ID_DTS },
-   { wxT("dvd"), CODEC_ID_PCM_S16BE },
-   { wxT("dvd"), CODEC_ID_MP2 },
-
-   { wxT("nut"), CODEC_ID_PCM_S16LE },
-   { wxT("nut"), CODEC_ID_PCM_U8 },
-   { wxT("nut"), CODEC_ID_PCM_S24LE },
-   { wxT("nut"), CODEC_ID_PCM_S32LE },
-   { wxT("nut"), CODEC_ID_ADPCM_MS },
-   { wxT("nut"), CODEC_ID_PCM_ALAW },
-   { wxT("nut"), CODEC_ID_PCM_MULAW },
-   { wxT("nut"), CODEC_ID_WMAVOICE },
-   { wxT("nut"), CODEC_ID_ADPCM_IMA_WAV },
-   { wxT("nut"), CODEC_ID_ADPCM_YAMAHA },
-   { wxT("nut"), CODEC_ID_TRUESPEECH },
-   { wxT("nut"), CODEC_ID_GSM_MS },
-   { wxT("nut"), CODEC_ID_ADPCM_G726 },
-   { wxT("nut"), CODEC_ID_MP2 },
-   { wxT("nut"), CODEC_ID_MP3 },
-   { wxT("nut"), CODEC_ID_VOXWARE },
-   { wxT("nut"), CODEC_ID_AAC },
-   { wxT("nut"), CODEC_ID_WMAV1 },
-   { wxT("nut"), CODEC_ID_WMAV2 },
-   { wxT("nut"), CODEC_ID_WMAPRO },
-   { wxT("nut"), CODEC_ID_ADPCM_CT },
-   { wxT("nut"), CODEC_ID_ATRAC3 },
-   { wxT("nut"), CODEC_ID_IMC },
-   { wxT("nut"), CODEC_ID_AC3 },
-   { wxT("nut"), CODEC_ID_DTS },
-   { wxT("nut"), CODEC_ID_SONIC },
-   { wxT("nut"), CODEC_ID_SONIC_LS },
-   { wxT("nut"), CODEC_ID_FLAC },
-   { wxT("nut"), CODEC_ID_ADPCM_SWF },
-   { wxT("nut"), CODEC_ID_VORBIS },
-
-   { wxT("ogg"), CODEC_ID_VORBIS },
-   { wxT("ogg"), CODEC_ID_FLAC },
-
-   { wxT("ac3"), CODEC_ID_AC3 },
-
-   { wxT("dts"), CODEC_ID_DTS },
-
-   { wxT("flac"), CODEC_ID_FLAC },
-
-   { wxT("RoQ"), CODEC_ID_ROQ_DPCM },
-
-   { wxT("rm"), CODEC_ID_AC3 },
-
-   { wxT("swf"), CODEC_ID_MP3 },
-
-   { wxT("avm2"), CODEC_ID_MP3 },
-
-   { wxT("voc"), CODEC_ID_PCM_U8 },
-
-   { wxT("wav"), CODEC_ID_PCM_S16LE },
-   { wxT("wav"), CODEC_ID_PCM_U8 },
-   { wxT("wav"), CODEC_ID_PCM_S24LE },
-   { wxT("wav"), CODEC_ID_PCM_S32LE },
-   { wxT("wav"), CODEC_ID_ADPCM_MS },
-   { wxT("wav"), CODEC_ID_PCM_ALAW },
-   { wxT("wav"), CODEC_ID_PCM_MULAW },
-   { wxT("wav"), CODEC_ID_WMAVOICE },
-   { wxT("wav"), CODEC_ID_ADPCM_IMA_WAV },
-   { wxT("wav"), CODEC_ID_ADPCM_YAMAHA },
-   { wxT("wav"), CODEC_ID_TRUESPEECH },
-   { wxT("wav"), CODEC_ID_GSM_MS },
-   { wxT("wav"), CODEC_ID_ADPCM_G726 },
-   { wxT("wav"), CODEC_ID_MP2 },
-   { wxT("wav"), CODEC_ID_MP3 },
-   { wxT("wav"), CODEC_ID_VOXWARE },
-   { wxT("wav"), CODEC_ID_AAC },
-   { wxT("wav"), CODEC_ID_WMAV1 },
-   { wxT("wav"), CODEC_ID_WMAV2 },
-   { wxT("wav"), CODEC_ID_WMAPRO },
-   { wxT("wav"), CODEC_ID_ADPCM_CT },
-   { wxT("wav"), CODEC_ID_ATRAC3 },
-   { wxT("wav"), CODEC_ID_IMC },
-   { wxT("wav"), CODEC_ID_AC3 },
-   { wxT("wav"), CODEC_ID_DTS },
-   { wxT("wav"), CODEC_ID_SONIC },
-   { wxT("wav"), CODEC_ID_SONIC_LS },
-   { wxT("wav"), CODEC_ID_FLAC },
-   { wxT("wav"), CODEC_ID_ADPCM_SWF },
-   { wxT("wav"), CODEC_ID_VORBIS },
+   { wxT("aiff"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("aiff"), AV_CODEC_ID_PCM_S8 },
+   { wxT("aiff"), AV_CODEC_ID_PCM_S24BE },
+   { wxT("aiff"), AV_CODEC_ID_PCM_S32BE },
+   { wxT("aiff"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("aiff"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("aiff"), AV_CODEC_ID_MACE3 },
+   { wxT("aiff"), AV_CODEC_ID_MACE6 },
+   { wxT("aiff"), AV_CODEC_ID_GSM },
+   { wxT("aiff"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("aiff"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("aiff"), AV_CODEC_ID_ADPCM_IMA_QT },
+   { wxT("aiff"), AV_CODEC_ID_QDM2 },
+
+   { wxT("amr"), AV_CODEC_ID_AMR_NB },
+   { wxT("amr"), AV_CODEC_ID_AMR_WB },
+
+   { wxT("asf"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("asf"), AV_CODEC_ID_PCM_U8 },
+   { wxT("asf"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("asf"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_MS },
+   { wxT("asf"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("asf"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("asf"), AV_CODEC_ID_WMAVOICE },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_IMA_WAV },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_YAMAHA },
+   { wxT("asf"), AV_CODEC_ID_TRUESPEECH },
+   { wxT("asf"), AV_CODEC_ID_GSM_MS },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("asf"), AV_CODEC_ID_MP2 },
+   { wxT("asf"), AV_CODEC_ID_MP3 },
+   { wxT("asf"), AV_CODEC_ID_VOXWARE },
+   { wxT("asf"), AV_CODEC_ID_AAC },
+   { wxT("asf"), AV_CODEC_ID_WMAV1 },
+   { wxT("asf"), AV_CODEC_ID_WMAV2 },
+   { wxT("asf"), AV_CODEC_ID_WMAPRO },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_CT },
+   { wxT("asf"), AV_CODEC_ID_ATRAC3 },
+   { wxT("asf"), AV_CODEC_ID_IMC },
+   { wxT("asf"), AV_CODEC_ID_AC3 },
+   { wxT("asf"), AV_CODEC_ID_DTS },
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_MAJOR == 53)
+   { wxT("asf"), AV_CODEC_ID_SONIC },
+   { wxT("asf"), AV_CODEC_ID_SONIC_LS },
+#endif
+   { wxT("asf"), AV_CODEC_ID_FLAC },
+   { wxT("asf"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("asf"), AV_CODEC_ID_VORBIS },
+
+   { wxT("au"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("au"), AV_CODEC_ID_PCM_S8 },
+   { wxT("au"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("au"), AV_CODEC_ID_PCM_ALAW },
+
+   { wxT("avi"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("avi"), AV_CODEC_ID_PCM_U8 },
+   { wxT("avi"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("avi"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_MS },
+   { wxT("avi"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("avi"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("avi"), AV_CODEC_ID_WMAVOICE },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_IMA_WAV },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_YAMAHA },
+   { wxT("avi"), AV_CODEC_ID_TRUESPEECH },
+   { wxT("avi"), AV_CODEC_ID_GSM_MS },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("avi"), AV_CODEC_ID_MP2 },
+   { wxT("avi"), AV_CODEC_ID_MP3 },
+   { wxT("avi"), AV_CODEC_ID_VOXWARE },
+   { wxT("avi"), AV_CODEC_ID_AAC },
+   { wxT("avi"), AV_CODEC_ID_WMAV1 },
+   { wxT("avi"), AV_CODEC_ID_WMAV2 },
+   { wxT("avi"), AV_CODEC_ID_WMAPRO },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_CT },
+   { wxT("avi"), AV_CODEC_ID_ATRAC3 },
+   { wxT("avi"), AV_CODEC_ID_IMC },
+   { wxT("avi"), AV_CODEC_ID_AC3 },
+   { wxT("avi"), AV_CODEC_ID_DTS },
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_MAJOR == 53)
+   { wxT("avi"), AV_CODEC_ID_SONIC },
+   { wxT("avi"), AV_CODEC_ID_SONIC_LS },
+#endif
+   { wxT("avi"), AV_CODEC_ID_FLAC },
+   { wxT("avi"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("avi"), AV_CODEC_ID_VORBIS },
+
+   { wxT("crc"), AV_CODEC_ID_NONE },
+
+   { wxT("dv"), AV_CODEC_ID_PCM_S16LE },
+
+   { wxT("ffm"), AV_CODEC_ID_NONE },
+
+   { wxT("flv"), AV_CODEC_ID_MP3 },
+   { wxT("flv"), AV_CODEC_ID_PCM_S8 },
+   { wxT("flv"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("flv"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("flv"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("flv"), AV_CODEC_ID_AAC },
+   { wxT("flv"), AV_CODEC_ID_NELLYMOSER },
+
+   { wxT("framecrc"), AV_CODEC_ID_NONE },
+
+   { wxT("gxf"), AV_CODEC_ID_PCM_S16LE },
+
+   { wxT("matroska"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("matroska"), AV_CODEC_ID_PCM_U8 },
+   { wxT("matroska"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("matroska"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_MS },
+   { wxT("matroska"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("matroska"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("matroska"), AV_CODEC_ID_WMAVOICE },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_IMA_WAV },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_YAMAHA },
+   { wxT("matroska"), AV_CODEC_ID_TRUESPEECH },
+   { wxT("matroska"), AV_CODEC_ID_GSM_MS },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("matroska"), AV_CODEC_ID_MP2 },
+   { wxT("matroska"), AV_CODEC_ID_MP3 },
+   { wxT("matroska"), AV_CODEC_ID_VOXWARE },
+   { wxT("matroska"), AV_CODEC_ID_AAC },
+   { wxT("matroska"), AV_CODEC_ID_WMAV1 },
+   { wxT("matroska"), AV_CODEC_ID_WMAV2 },
+   { wxT("matroska"), AV_CODEC_ID_WMAPRO },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_CT },
+   { wxT("matroska"), AV_CODEC_ID_ATRAC3 },
+   { wxT("matroska"), AV_CODEC_ID_IMC },
+   { wxT("matroska"), AV_CODEC_ID_AC3 },
+   { wxT("matroska"), AV_CODEC_ID_DTS },
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_MAJOR == 53)
+   { wxT("matroska"), AV_CODEC_ID_SONIC },
+   { wxT("matroska"), AV_CODEC_ID_SONIC_LS },
+#endif
+   { wxT("matroska"), AV_CODEC_ID_FLAC },
+   { wxT("matroska"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("matroska"), AV_CODEC_ID_VORBIS },
+
+   { wxT("mmf"), AV_CODEC_ID_ADPCM_YAMAHA },
+
+   { wxT("mov"), AV_CODEC_ID_PCM_S32BE }, //mov
+   { wxT("mov"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("mov"), AV_CODEC_ID_PCM_S24BE },
+   { wxT("mov"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("mov"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("mov"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("mov"), AV_CODEC_ID_PCM_S8 },
+   { wxT("mov"), AV_CODEC_ID_PCM_U8 },
+   { wxT("mov"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("mov"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("mov"), AV_CODEC_ID_ADPCM_IMA_QT },
+   { wxT("mov"), AV_CODEC_ID_MACE3 },
+   { wxT("mov"), AV_CODEC_ID_MACE6 },
+   { wxT("mov"), AV_CODEC_ID_MP3 },
+   { wxT("mov"), AV_CODEC_ID_AAC },
+   { wxT("mov"), AV_CODEC_ID_AMR_NB },
+   { wxT("mov"), AV_CODEC_ID_AMR_WB },
+   { wxT("mov"), AV_CODEC_ID_GSM },
+   { wxT("mov"), AV_CODEC_ID_ALAC },
+   { wxT("mov"), AV_CODEC_ID_QCELP },
+   { wxT("mov"), AV_CODEC_ID_QDM2 },
+   { wxT("mov"), AV_CODEC_ID_DVAUDIO },
+   { wxT("mov"), AV_CODEC_ID_WMAV2 },
+   { wxT("mov"), AV_CODEC_ID_ALAC },
+
+   { wxT("mp4"), AV_CODEC_ID_AAC },
+   { wxT("mp4"), AV_CODEC_ID_QCELP },
+   { wxT("mp4"), AV_CODEC_ID_MP3 },
+   { wxT("mp4"), AV_CODEC_ID_VORBIS },
+
+   { wxT("psp"), AV_CODEC_ID_AAC },
+   { wxT("psp"), AV_CODEC_ID_QCELP },
+   { wxT("psp"), AV_CODEC_ID_MP3 },
+   { wxT("psp"), AV_CODEC_ID_VORBIS },
+
+   { wxT("ipod"), AV_CODEC_ID_AAC },
+   { wxT("ipod"), AV_CODEC_ID_QCELP },
+   { wxT("ipod"), AV_CODEC_ID_MP3 },
+   { wxT("ipod"), AV_CODEC_ID_VORBIS },
+
+   { wxT("3gp"), AV_CODEC_ID_AAC },
+   { wxT("3gp"), AV_CODEC_ID_AMR_NB },
+   { wxT("3gp"), AV_CODEC_ID_AMR_WB },
+
+   { wxT("3g2"), AV_CODEC_ID_AAC },
+   { wxT("3g2"), AV_CODEC_ID_AMR_NB },
+   { wxT("3g2"), AV_CODEC_ID_AMR_WB },
+
+   { wxT("mp3"), AV_CODEC_ID_MP3 },
+
+   { wxT("mpeg"), AV_CODEC_ID_AC3 },
+   { wxT("mpeg"), AV_CODEC_ID_DTS },
+   { wxT("mpeg"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("mpeg"), AV_CODEC_ID_MP2 },
+
+   { wxT("vcd"), AV_CODEC_ID_AC3 },
+   { wxT("vcd"), AV_CODEC_ID_DTS },
+   { wxT("vcd"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("vcd"), AV_CODEC_ID_MP2 },
+
+   { wxT("vob"), AV_CODEC_ID_AC3 },
+   { wxT("vob"), AV_CODEC_ID_DTS },
+   { wxT("vob"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("vob"), AV_CODEC_ID_MP2 },
+
+   { wxT("svcd"), AV_CODEC_ID_AC3 },
+   { wxT("svcd"), AV_CODEC_ID_DTS },
+   { wxT("svcd"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("svcd"), AV_CODEC_ID_MP2 },
+
+   { wxT("dvd"), AV_CODEC_ID_AC3 },
+   { wxT("dvd"), AV_CODEC_ID_DTS },
+   { wxT("dvd"), AV_CODEC_ID_PCM_S16BE },
+   { wxT("dvd"), AV_CODEC_ID_MP2 },
+
+   { wxT("nut"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("nut"), AV_CODEC_ID_PCM_U8 },
+   { wxT("nut"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("nut"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_MS },
+   { wxT("nut"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("nut"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("nut"), AV_CODEC_ID_WMAVOICE },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_IMA_WAV },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_YAMAHA },
+   { wxT("nut"), AV_CODEC_ID_TRUESPEECH },
+   { wxT("nut"), AV_CODEC_ID_GSM_MS },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("nut"), AV_CODEC_ID_MP2 },
+   { wxT("nut"), AV_CODEC_ID_MP3 },
+   { wxT("nut"), AV_CODEC_ID_VOXWARE },
+   { wxT("nut"), AV_CODEC_ID_AAC },
+   { wxT("nut"), AV_CODEC_ID_WMAV1 },
+   { wxT("nut"), AV_CODEC_ID_WMAV2 },
+   { wxT("nut"), AV_CODEC_ID_WMAPRO },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_CT },
+   { wxT("nut"), AV_CODEC_ID_ATRAC3 },
+   { wxT("nut"), AV_CODEC_ID_IMC },
+   { wxT("nut"), AV_CODEC_ID_AC3 },
+   { wxT("nut"), AV_CODEC_ID_DTS },
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_MAJOR == 53)
+   { wxT("nut"), AV_CODEC_ID_SONIC },
+   { wxT("nut"), AV_CODEC_ID_SONIC_LS },
+#endif
+   { wxT("nut"), AV_CODEC_ID_FLAC },
+   { wxT("nut"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("nut"), AV_CODEC_ID_VORBIS },
+
+   { wxT("ogg"), AV_CODEC_ID_VORBIS },
+   { wxT("ogg"), AV_CODEC_ID_FLAC },
+
+   { wxT("ac3"), AV_CODEC_ID_AC3 },
+
+   { wxT("dts"), AV_CODEC_ID_DTS },
+
+   { wxT("flac"), AV_CODEC_ID_FLAC },
+
+   { wxT("RoQ"), AV_CODEC_ID_ROQ_DPCM },
+
+   { wxT("rm"), AV_CODEC_ID_AC3 },
+
+   { wxT("swf"), AV_CODEC_ID_MP3 },
+
+   { wxT("avm2"), AV_CODEC_ID_MP3 },
+
+   { wxT("voc"), AV_CODEC_ID_PCM_U8 },
+
+   { wxT("wav"), AV_CODEC_ID_PCM_S16LE },
+   { wxT("wav"), AV_CODEC_ID_PCM_U8 },
+   { wxT("wav"), AV_CODEC_ID_PCM_S24LE },
+   { wxT("wav"), AV_CODEC_ID_PCM_S32LE },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_MS },
+   { wxT("wav"), AV_CODEC_ID_PCM_ALAW },
+   { wxT("wav"), AV_CODEC_ID_PCM_MULAW },
+   { wxT("wav"), AV_CODEC_ID_WMAVOICE },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_IMA_WAV },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_YAMAHA },
+   { wxT("wav"), AV_CODEC_ID_TRUESPEECH },
+   { wxT("wav"), AV_CODEC_ID_GSM_MS },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_G726 },
+   { wxT("wav"), AV_CODEC_ID_MP2 },
+   { wxT("wav"), AV_CODEC_ID_MP3 },
+   { wxT("wav"), AV_CODEC_ID_VOXWARE },
+   { wxT("wav"), AV_CODEC_ID_AAC },
+   { wxT("wav"), AV_CODEC_ID_WMAV1 },
+   { wxT("wav"), AV_CODEC_ID_WMAV2 },
+   { wxT("wav"), AV_CODEC_ID_WMAPRO },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_CT },
+   { wxT("wav"), AV_CODEC_ID_ATRAC3 },
+   { wxT("wav"), AV_CODEC_ID_IMC },
+   { wxT("wav"), AV_CODEC_ID_AC3 },
+   { wxT("wav"), AV_CODEC_ID_DTS },
+#if !defined(DISABLE_DYNAMIC_LOADING_FFMPEG) || (LIBAVCODEC_VERSION_MAJOR == 53)
+   { wxT("wav"), AV_CODEC_ID_SONIC },
+   { wxT("wav"), AV_CODEC_ID_SONIC_LS },
+#endif
+   { wxT("wav"), AV_CODEC_ID_FLAC },
+   { wxT("wav"), AV_CODEC_ID_ADPCM_SWF },
+   { wxT("wav"), AV_CODEC_ID_VORBIS },
 
-   { NULL, CODEC_ID_NONE }
+   { NULL, AV_CODEC_ID_NONE }
 };
 
 /// AAC profiles
@@ -1110,11 +1120,11 @@
 /// List of export types
 ExposedFormat ExportFFmpegOptions::fmts[] =
 {
-   {FMT_M4A,   wxT("M4A"),    wxT("m4a"), wxT("ipod"), 48,  AV_VERSION_INT(-1,-1,-1), true,  _("M4A (AAC) Files (FFmpeg)"),         CODEC_ID_AAC,    true},
-   {FMT_AC3,   wxT("AC3"),    wxT("ac3"), wxT("ac3"),  7,   AV_VERSION_INT(0,0,0),    false, _("AC3 Files (FFmpeg)"),               CODEC_ID_AC3,    true},
-   {FMT_AMRNB, wxT("AMRNB"),  wxT("amr"), wxT("amr"),  1,   AV_VERSION_INT(0,0,0),    false, _("AMR (narrow band) Files (FFmpeg)"), CODEC_ID_AMR_NB, true},
-   {FMT_WMA2,  wxT("WMA"),    wxT("wma"), wxT("asf"),  2,   AV_VERSION_INT(52,53,0),  false, _("WMA (version 2) Files (FFmpeg)"),   CODEC_ID_WMAV2,  true},
-   {FMT_OTHER, wxT("FFMPEG"), wxT(""),    wxT(""),     255, AV_VERSION_INT(-1,-1,-1), true,  _("Custom FFmpeg Export"),             CODEC_ID_NONE,   true}
+   {FMT_M4A,   wxT("M4A"),    wxT("m4a"), wxT("ipod"), 48,  AV_VERSION_INT(-1,-1,-1), true,  _("M4A (AAC) Files (FFmpeg)"),         AV_CODEC_ID_AAC,    true},
+   {FMT_AC3,   wxT("AC3"),    wxT("ac3"), wxT("ac3"),  7,   AV_VERSION_INT(0,0,0),    false, _("AC3 Files (FFmpeg)"),               AV_CODEC_ID_AC3,    true},
+   {FMT_AMRNB, wxT("AMRNB"),  wxT("amr"), wxT("amr"),  1,   AV_VERSION_INT(0,0,0),    false, _("AMR (narrow band) Files (FFmpeg)"), AV_CODEC_ID_AMR_NB, true},
+   {FMT_WMA2,  wxT("WMA"),    wxT("wma"), wxT("asf"),  2,   AV_VERSION_INT(52,53,0),  false, _("WMA (version 2) Files (FFmpeg)"),   AV_CODEC_ID_WMAV2,  true},
+   {FMT_OTHER, wxT("FFMPEG"), wxT(""),    wxT(""),     255, AV_VERSION_INT(-1,-1,-1), true,  _("Custom FFmpeg Export"),             AV_CODEC_ID_NONE,   true}
 };
 
 /// Sample rates supported by AAC encoder (must end with zero-element)
@@ -1125,84 +1135,84 @@
 /// Syntax: first, enable a control for each applicable format-codec combination
 /// then disable it for anything else
 /// "any" - any format
-/// CODEC_ID_NONE - any codec
-/// This list must end with {FALSE,FFmpegExportCtrlID(0),CODEC_ID_NONE,NULL}
-ApplicableFor ExportFFmpegOptions::apptable[] = 
-{
-   {TRUE,FEQualityID,CODEC_ID_AAC,"any"},
-   {TRUE,FEQualityID,CODEC_ID_MP3,"any"},
-   {TRUE,FEQualityID,CODEC_ID_VORBIS,"any"},
-   {FALSE,FEQualityID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FECutoffID,CODEC_ID_AC3,"any"},
-   {TRUE,FECutoffID,CODEC_ID_AAC,"any"},
-   {TRUE,FECutoffID,CODEC_ID_VORBIS,"any"},
-   {FALSE,FECutoffID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEFrameSizeID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEFrameSizeID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEProfileID,CODEC_ID_AAC,"any"},
-   {FALSE,FEProfileID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FECompLevelID,CODEC_ID_FLAC,"any"},
-   {FALSE,FECompLevelID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEUseLPCID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEUseLPCID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FELPCCoeffsID,CODEC_ID_FLAC,"any"},
-   {FALSE,FELPCCoeffsID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEMinPredID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEMinPredID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEMaxPredID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEMaxPredID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEPredOrderID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEPredOrderID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEMinPartOrderID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEMinPartOrderID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEMaxPartOrderID,CODEC_ID_FLAC,"any"},
-   {FALSE,FEMaxPartOrderID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEMuxRateID,CODEC_ID_NONE,"mpeg"},
-   {TRUE,FEMuxRateID,CODEC_ID_NONE,"vcd"},
-   {TRUE,FEMuxRateID,CODEC_ID_NONE,"vob"},
-   {TRUE,FEMuxRateID,CODEC_ID_NONE,"svcd"},
-   {TRUE,FEMuxRateID,CODEC_ID_NONE,"dvd"},
-   {FALSE,FEMuxRateID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEPacketSizeID,CODEC_ID_NONE,"mpeg"},
-   {TRUE,FEPacketSizeID,CODEC_ID_NONE,"vcd"},
-   {TRUE,FEPacketSizeID,CODEC_ID_NONE,"vob"},
-   {TRUE,FEPacketSizeID,CODEC_ID_NONE,"svcd"},
-   {TRUE,FEPacketSizeID,CODEC_ID_NONE,"dvd"},
-   {FALSE,FEPacketSizeID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FELanguageID,CODEC_ID_NONE,"matroska"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"mov"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"3gp"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"mp4"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"psp"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"3g2"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"ipod"},
-   {TRUE,FELanguageID,CODEC_ID_NONE,"mpegts"},
-   {FALSE,FELanguageID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEBitReservoirID,CODEC_ID_MP3,"any"},
-   {TRUE,FEBitReservoirID,CODEC_ID_WMAV1,"any"},
-   {TRUE,FEBitReservoirID,CODEC_ID_WMAV2,"any"},
-   {FALSE,FEBitReservoirID,CODEC_ID_NONE,"any"},
-
-   {TRUE,FEVariableBlockLenID,CODEC_ID_WMAV1,"any"},
-   {TRUE,FEVariableBlockLenID,CODEC_ID_WMAV2,"any"},
-   {FALSE,FEVariableBlockLenID,CODEC_ID_NONE,"any"},
+/// AV_CODEC_ID_NONE - any codec
+/// This list must end with {FALSE,FFmpegExportCtrlID(0),AV_CODEC_ID_NONE,NULL}
+ApplicableFor ExportFFmpegOptions::apptable[] =
+{
+   {TRUE,FEQualityID,AV_CODEC_ID_AAC,"any"},
+   {TRUE,FEQualityID,AV_CODEC_ID_MP3,"any"},
+   {TRUE,FEQualityID,AV_CODEC_ID_VORBIS,"any"},
+   {FALSE,FEQualityID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FECutoffID,AV_CODEC_ID_AC3,"any"},
+   {TRUE,FECutoffID,AV_CODEC_ID_AAC,"any"},
+   {TRUE,FECutoffID,AV_CODEC_ID_VORBIS,"any"},
+   {FALSE,FECutoffID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEFrameSizeID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEFrameSizeID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEProfileID,AV_CODEC_ID_AAC,"any"},
+   {FALSE,FEProfileID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FECompLevelID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FECompLevelID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEUseLPCID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEUseLPCID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FELPCCoeffsID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FELPCCoeffsID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEMinPredID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEMinPredID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEMaxPredID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEMaxPredID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEPredOrderID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEPredOrderID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEMinPartOrderID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEMinPartOrderID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEMaxPartOrderID,AV_CODEC_ID_FLAC,"any"},
+   {FALSE,FEMaxPartOrderID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEMuxRateID,AV_CODEC_ID_NONE,"mpeg"},
+   {TRUE,FEMuxRateID,AV_CODEC_ID_NONE,"vcd"},
+   {TRUE,FEMuxRateID,AV_CODEC_ID_NONE,"vob"},
+   {TRUE,FEMuxRateID,AV_CODEC_ID_NONE,"svcd"},
+   {TRUE,FEMuxRateID,AV_CODEC_ID_NONE,"dvd"},
+   {FALSE,FEMuxRateID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEPacketSizeID,AV_CODEC_ID_NONE,"mpeg"},
+   {TRUE,FEPacketSizeID,AV_CODEC_ID_NONE,"vcd"},
+   {TRUE,FEPacketSizeID,AV_CODEC_ID_NONE,"vob"},
+   {TRUE,FEPacketSizeID,AV_CODEC_ID_NONE,"svcd"},
+   {TRUE,FEPacketSizeID,AV_CODEC_ID_NONE,"dvd"},
+   {FALSE,FEPacketSizeID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"matroska"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"mov"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"3gp"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"mp4"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"psp"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"3g2"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"ipod"},
+   {TRUE,FELanguageID,AV_CODEC_ID_NONE,"mpegts"},
+   {FALSE,FELanguageID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEBitReservoirID,AV_CODEC_ID_MP3,"any"},
+   {TRUE,FEBitReservoirID,AV_CODEC_ID_WMAV1,"any"},
+   {TRUE,FEBitReservoirID,AV_CODEC_ID_WMAV2,"any"},
+   {FALSE,FEBitReservoirID,AV_CODEC_ID_NONE,"any"},
+
+   {TRUE,FEVariableBlockLenID,AV_CODEC_ID_WMAV1,"any"},
+   {TRUE,FEVariableBlockLenID,AV_CODEC_ID_WMAV2,"any"},
+   {FALSE,FEVariableBlockLenID,AV_CODEC_ID_NONE,"any"},
 
-   {FALSE,FFmpegExportCtrlID(0),CODEC_ID_NONE,NULL}
+   {FALSE,FFmpegExportCtrlID(0),AV_CODEC_ID_NONE,NULL}
 };
 
 /// Prediction order method - names. Labels are indices of this array.
@@ -1251,7 +1261,7 @@
       DoOnFormatList();
 
       //Select the codec that was selected last time this dialog was closed
-      AVCodec *codec = avcodec_find_encoder((CodecID)gPrefs->Read(wxT("/FileFormats/FFmpegCodec"),(long)CODEC_ID_NONE));
+      AVCodec *codec = avcodec_find_encoder_by_name(gPrefs->Read(wxT("/FileFormats/FFmpegCodec")).ToUTF8());
       if (codec != NULL) mCodecList->Select(mCodecList->FindString(wxString::FromUTF8(codec->name)));
       DoOnCodecList();
    }
@@ -1268,7 +1278,7 @@
    {
       // Any audio-capable format has default audio codec.
       // If it doesn't, then it doesn't supports any audio codecs
-      if (ofmt->audio_codec != CODEC_ID_NONE)
+      if (ofmt->audio_codec != AV_CODEC_ID_NONE)
       {
          mFormatNames.Add(wxString::FromUTF8(ofmt->name));
          mFormatLongNames.Add(wxString::Format(wxT("%s - %s"),mFormatNames.Last().c_str(),wxString::FromUTF8(ofmt->long_name).c_str()));
@@ -1288,7 +1298,7 @@
    while ((codec = av_codec_next(codec)))
    {
       // We're only interested in audio and only in encoders
-      if (codec->type == CODEC_TYPE_AUDIO && codec->encode)
+      if (codec->type == AVMEDIA_TYPE_AUDIO && av_codec_is_encoder(codec))
       {
          mCodecNames.Add(wxString::FromUTF8(codec->name));
          mCodecLongNames.Add(wxString::Format(wxT("%s - %s"),mCodecNames.Last().c_str(),wxString::FromUTF8(codec->long_name).c_str()));
@@ -1299,157 +1309,156 @@
    mShownCodecLongNames = mCodecLongNames;
 }
 
-/// 
-/// 
+///
+///
 void ExportFFmpegOptions::PopulateOrExchange(ShuttleGui & S)
 {
    S.StartVerticalLay(1);
    S.StartMultiColumn(1, wxEXPAND);
    {
-     S.SetStretchyRow(3);
-     S.StartMultiColumn(7, wxEXPAND);
-     {
-        S.SetStretchyCol(1);
-        mPresetCombo = S.Id(FEPresetID).AddCombo(_("Preset:"), gPrefs->Read(wxT("/FileFormats/FFmpegPreset"),wxEmptyString), mPresetNames);
-        mLoadPreset = S.Id(FELoadPresetID).AddButton(_("Load Preset"));
-        mSavePreset = S.Id(FESavePresetID).AddButton(_("Save Preset"));
-        mDeletePreset = S.Id(FEDeletePresetID).AddButton(_("Delete Preset"));
-        mImportPresets = S.Id(FEImportPresetsID).AddButton(_("Import Presets"));
-        mExportPresets = S.Id(FEExportPresetsID).AddButton(_("Export Presets"));
-     }
-     S.EndMultiColumn();
-     S.StartMultiColumn(4, wxALIGN_LEFT);
-     {
-        S.SetStretchyCol(1);
-        S.SetStretchyCol(3);
-        S.Id(FEFormatLabelID).AddFixedText(_("Format:"));
-        mFormatName = S.Id(FEFormatNameID).AddVariableText(wxT(""));
-        S.Id(FECodecLabelID).AddFixedText(_("Codec:"));
-        mCodecName = S.Id(FECodecNameID).AddVariableText(wxT(""));
-     }
-     S.EndMultiColumn();
-     S.AddVariableText(_("Not all formats and codecs are compatible. Nor are all option combinations compatible with all codecs."), false);
-     S.StartMultiColumn(2, wxEXPAND);
-     {
-        S.StartMultiColumn(2, wxEXPAND);
-        {
-          S.SetStretchyRow(1);
-          S.Id(FEAllFormatsID).AddButton(_("Show All Formats"));
-          S.Id(FEAllCodecsID).AddButton(_("Show All Codecs"));
-          mFormatList = S.Id(FEFormatID).AddListBox(&mFormatNames);
-          mFormatList->DeselectAll();
-          mCodecList = S.Id(FECodecID).AddListBox(&mCodecNames);
-          mCodecList->DeselectAll();
-        }
-        S.EndMultiColumn();
-        S.StartVerticalLay();
-        {
-//         S.StartScroller( );
-           S.SetBorder( 3 );
-           S.StartStatic(_("General Options"), 0);
-           {
-              S.StartMultiColumn(8, wxEXPAND);
-              {
-                 mLanguageText = S.Id(FELanguageID).TieTextBox(_("Language:"), wxT("/FileFormats/FFmpegLanguage"), wxEmptyString, 9);
-                 mLanguageText->SetToolTip(_("ISO 639 3-letter language code\nOptional\nempty - automatic"));
-
-                 S.AddSpace( 20,0 );
-                 S.AddVariableText(_("Bit Reservoir"));
-                 S.Id(FEBitReservoirID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegBitReservoir"), true);
-
-                 S.AddSpace( 20,0 );
-                 S.AddVariableText(_("VBL"));
-                 S.Id(FEVariableBlockLenID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegVariableBlockLen"), true);
-              }
-              S.EndMultiColumn();
-              S.StartMultiColumn(4, wxALIGN_LEFT);
-              {
-                 mTag = S.Id(FETagID).TieTextBox(_("Tag:"), wxT("/FileFormats/FFmpegTag"), wxEmptyString, 4);
-                 mTag->SetToolTip(_("Codec tag (FOURCC)\nOptional\nempty - automatic"));
-
-                 mBitrateSpin = S.Id(FEBitrateID).TieSpinCtrl(_("Bit Rate:"), wxT("/FileFormats/FFmpegBitRate"), 0, 1000000, 0);
-                 mBitrateSpin->SetToolTip(_("Bit Rate (bits/second) - influences the resulting file size and quality\nSome codecs may only accept specific values (128k, 192k, 256k etc)\n0 - automatic\nRecommended - 192000"));
-
-                 mQualitySpin = S.Id(FEQualityID).TieSpinCtrl(_("Quality:"), wxT("/FileFormats/FFmpegQuality"), 0, 500, -1);
-                 mQualitySpin->SetToolTip(_("Overall quality, used differently by different codecs\nRequired for vorbis\n0 - automatic\n-1 - off (use bitrate instead)"));
-
-                 mSampleRateSpin = S.Id(FESampleRateID).TieSpinCtrl(_("Sample Rate:"), wxT("/FileFormats/FFmpegSampleRate"), 0, 200000, 0);
-                 mSampleRateSpin->SetToolTip(_("Sample rate (Hz)\n0 - don't change sample rate"));
-
-                 mCutoffSpin = S.Id(FECutoffID).TieSpinCtrl(_("Cutoff:"), wxT("/FileFormats/FFmpegCutOff"), 0, 10000000, 0);
-                 mCutoffSpin->SetToolTip(_("Audio cutoff bandwidth (Hz)\nOptional\n0 - automatic"));
-
-                 mProfileChoice = S.Id(FEProfileID).TieChoice(_("Profile:"), wxT("/FileFormats/FFmpegAACProfile"), 
-                    mProfileLabels[0], mProfileNames, mProfileLabels);
-                 mProfileChoice->SetSizeHints( 100,-1);
-                 mProfileChoice->SetToolTip(_("AAC Profile\nLow Complexity -default\nMost players won't play anything other than LC"));
-
-              }
-              S.EndMultiColumn();
-           }
-           S.EndStatic();
-           S.StartStatic(_("FLAC options"),0);
-           {
-              S.StartMultiColumn(4, wxALIGN_LEFT);
-              {
-                 mCompressionLevelSpin = S.Id(FECompLevelID).TieSpinCtrl(_("Compression:"), wxT("/FileFormats/FFmpegCompLevel"), 0, 10, -1);
-                 mCompressionLevelSpin->SetToolTip(_("Compression level\nRequired for FLAC\n-1 - automatic\nmin - 0 (fast encoding, large output file)\nmax - 10 (slow encoding, small output file)"));
-
-                 mFrameSizeSpin =  S.Id(FEFrameSizeID).TieSpinCtrl(_("Frame:"), wxT("/FileFormats/FFmpegFrameSize"), 0, 65535, 0);
-                 mFrameSizeSpin->SetToolTip(_("Frame size\nOptional\n0 - default\nmin - 16\nmax - 65535"));
-
-                 mLPCCoeffsPrecisionSpin = S.Id(FELPCCoeffsID).TieSpinCtrl(_("LPC"), wxT("/FileFormats/FFmpegLPCCoefPrec"), 0, 15, 0);
-                 mLPCCoeffsPrecisionSpin->SetToolTip(_("LPC coefficients precision\nOptional\n0 - default\nmin - 1\nmax - 15"));
-
-                 mPredictionOrderMethodChoice = S.Id(FEPredOrderID).TieChoice(_("PdO Method:"), wxT("/FileFormats/FFmpegPredOrderMethod"), 
-                    mPredictionOrderMethodLabels[4], mPredictionOrderMethodNames, mPredictionOrderMethodLabels);
-                 mPredictionOrderMethodChoice->SetSizeHints( 100,-1);
-                 mPredictionOrderMethodChoice->SetToolTip(_("Prediction Order Method\nEstimate - fastest, lower compression\nLog search - slowest, best compression\nFull search - default"));
-
-                 mMinPredictionOrderSpin = S.Id(FEMinPredID).TieSpinCtrl(_("Min. PdO"), wxT("/FileFormats/FFmpegMinPredOrder"), -1, 32, -1);
-                 mMinPredictionOrderSpin->SetToolTip(_("Minimal prediction order\nOptional\n-1 - default\nmin - 0\nmax - 32 (with LPC) or 4 (without LPC)"));
-
-                 mMaxPredictionOrderSpin = S.Id(FEMaxPredID).TieSpinCtrl(_("Max. PdO"), wxT("/FileFormats/FFmpegMaxPredOrder"), -1, 32, -1);
-                 mMaxPredictionOrderSpin->SetToolTip(_("Maximal prediction order\nOptional\n-1 - default\nmin - 0\nmax - 32 (with LPC) or 4 (without LPC)"));
-
-                 mMinPartitionOrderSpin = S.Id(FEMinPartOrderID).TieSpinCtrl(_("Min. PtO"), wxT("/FileFormats/FFmpegMinPartOrder"), -1, 8, -1);
-                 mMinPartitionOrderSpin->SetToolTip(_("Minimal partition order\nOptional\n-1 - default\nmin - 0\nmax - 8"));
-
-                 mMaxPartitionOrderSpin = S.Id(FEMaxPartOrderID).TieSpinCtrl(_("Max. PtO"), wxT("/FileFormats/FFmpegMaxPredOrder"), -1, 8, -1);
-                 mMaxPartitionOrderSpin->SetToolTip(_("Maximal partition order\nOptional\n-1 - default\nmin - 0\nmax - 8"));
-
-                 S.AddVariableText(_("Use LPC"));
-                 S.Id(FEUseLPCID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegUseLPC"), true);
-                 
-              }
-              S.EndMultiColumn();
-           }
-           S.EndStatic();
-           S.StartStatic(_("MPEG container options"),0);
-           {
-              S.StartMultiColumn(4, wxALIGN_LEFT);
-              {
-                 /* i18n-hint: 'mux' is short for multiplexor, a device that selects between several inputs
-                   'Mux Rate' is a parameter that has some bearing on compression ratio for MPEG 
-                   it has a hard to predict effect on the degree of compression */
-                 mMuxRate = S.Id(FEMuxRateID).TieSpinCtrl(_("Mux Rate:"), wxT("/FileFormats/FFmpegMuxRate"), 0, 10000000, 0);
-                 mMuxRate->SetToolTip(_("Maximum bit rate of the multiplexed stream\nOptional\n0 - default"));
-
-                 /* i18n-hint: 'Packet Size' is a parameter that has some bearing on compression ratio for MPEG 
-                   compression.  It measures how big a chunk of audio is compressed in one piece. */
-                 mPacketSize = S.Id(FEPacketSizeID).TieSpinCtrl(_("Packet Size:"), wxT("/FileFormats/FFmpegPacketSize"), 0, 10000000, 0);
-                 mPacketSize->SetToolTip(_("Packet size\nOptional\n0 - default"));
-              }
-              S.EndMultiColumn();
-           }
-           S.EndStatic();
-//         S.EndScroller();
-           S.SetBorder( 5 );
-           S.AddStandardButtons();
-        }
-        S.EndVerticalLay();
-     }
-     S.EndMultiColumn();
+      S.SetStretchyRow(3);
+      S.StartMultiColumn(7, wxEXPAND);
+      {
+         S.SetStretchyCol(1);
+         mPresetCombo = S.Id(FEPresetID).AddCombo(_("Preset:"), gPrefs->Read(wxT("/FileFormats/FFmpegPreset"),wxEmptyString), mPresetNames);
+         mLoadPreset = S.Id(FELoadPresetID).AddButton(_("Load Preset"));
+         mSavePreset = S.Id(FESavePresetID).AddButton(_("Save Preset"));
+         mDeletePreset = S.Id(FEDeletePresetID).AddButton(_("Delete Preset"));
+         mImportPresets = S.Id(FEImportPresetsID).AddButton(_("Import Presets"));
+         mExportPresets = S.Id(FEExportPresetsID).AddButton(_("Export Presets"));
+      }
+      S.EndMultiColumn();
+      S.StartMultiColumn(4, wxALIGN_LEFT);
+      {
+         S.SetStretchyCol(1);
+         S.SetStretchyCol(3);
+         S.Id(FEFormatLabelID).AddFixedText(_("Format:"));
+         mFormatName = S.Id(FEFormatNameID).AddVariableText(wxT(""));
+         S.Id(FECodecLabelID).AddFixedText(_("Codec:"));
+         mCodecName = S.Id(FECodecNameID).AddVariableText(wxT(""));
+      }
+      S.EndMultiColumn();
+      S.AddVariableText(_("Not all formats and codecs are compatible. Nor are all option combinations compatible with all codecs."), false);
+      S.StartMultiColumn(2, wxEXPAND);
+      {
+         S.StartMultiColumn(2, wxEXPAND);
+         {
+            S.SetStretchyRow(1);
+            S.Id(FEAllFormatsID).AddButton(_("Show All Formats"));
+            S.Id(FEAllCodecsID).AddButton(_("Show All Codecs"));
+            mFormatList = S.Id(FEFormatID).AddListBox(&mFormatNames);
+            mFormatList->DeselectAll();
+            mCodecList = S.Id(FECodecID).AddListBox(&mCodecNames);
+            mCodecList->DeselectAll();
+         }
+         S.EndMultiColumn();
+         S.StartVerticalLay();
+         {
+            //S.StartScroller( );
+            S.SetBorder( 3 );
+            S.StartStatic(_("General Options"), 0);
+            {
+               S.StartMultiColumn(8, wxEXPAND);
+               {
+                  mLanguageText = S.Id(FELanguageID).TieTextBox(_("Language:"), wxT("/FileFormats/FFmpegLanguage"), wxEmptyString, 9);
+                  mLanguageText->SetToolTip(_("ISO 639 3-letter language code\nOptional\nempty - automatic"));
+
+                  S.AddSpace( 20,0 );
+                  S.AddVariableText(_("Bit Reservoir"));
+                  S.Id(FEBitReservoirID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegBitReservoir"), true);
+
+                  S.AddSpace( 20,0 );
+                  S.AddVariableText(_("VBL"));
+                  S.Id(FEVariableBlockLenID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegVariableBlockLen"), true);
+               }
+               S.EndMultiColumn();
+               S.StartMultiColumn(4, wxALIGN_LEFT);
+               {
+                  mTag = S.Id(FETagID).TieTextBox(_("Tag:"), wxT("/FileFormats/FFmpegTag"), wxEmptyString, 4);
+                  mTag->SetToolTip(_("Codec tag (FOURCC)\nOptional\nempty - automatic"));
+
+                  mBitrateSpin = S.Id(FEBitrateID).TieSpinCtrl(_("Bit Rate:"), wxT("/FileFormats/FFmpegBitRate"), 0, 1000000, 0);
+                  mBitrateSpin->SetToolTip(_("Bit Rate (bits/second) - influences the resulting file size and quality\nSome codecs may only accept specific values (128k, 192k, 256k etc)\n0 - automatic\nRecommended - 192000"));
+
+                  mQualitySpin = S.Id(FEQualityID).TieSpinCtrl(_("Quality:"), wxT("/FileFormats/FFmpegQuality"), 0, 500, -1);
+                  mQualitySpin->SetToolTip(_("Overall quality, used differently by different codecs\nRequired for vorbis\n0 - automatic\n-1 - off (use bitrate instead)"));
+
+                  mSampleRateSpin = S.Id(FESampleRateID).TieSpinCtrl(_("Sample Rate:"), wxT("/FileFormats/FFmpegSampleRate"), 0, 200000, 0);
+                  mSampleRateSpin->SetToolTip(_("Sample rate (Hz)\n0 - don't change sample rate"));
+
+                  mCutoffSpin = S.Id(FECutoffID).TieSpinCtrl(_("Cutoff:"), wxT("/FileFormats/FFmpegCutOff"), 0, 10000000, 0);
+                  mCutoffSpin->SetToolTip(_("Audio cutoff bandwidth (Hz)\nOptional\n0 - automatic"));
+
+                  mProfileChoice = S.Id(FEProfileID).TieChoice(_("Profile:"), wxT("/FileFormats/FFmpegAACProfile"),
+                     mProfileLabels[0], mProfileNames, mProfileLabels);
+                  mProfileChoice->SetSizeHints( 100,-1);
+                  mProfileChoice->SetToolTip(_("AAC Profile\nLow Complexity -default\nMost players won't play anything other than LC"));
+
+               }
+               S.EndMultiColumn();
+            }
+            S.EndStatic();
+            S.StartStatic(_("FLAC options"),0);
+            {
+               S.StartMultiColumn(4, wxALIGN_LEFT);
+               {
+                  mCompressionLevelSpin = S.Id(FECompLevelID).TieSpinCtrl(_("Compression:"), wxT("/FileFormats/FFmpegCompLevel"), 0, 10, -1);
+                  mCompressionLevelSpin->SetToolTip(_("Compression level\nRequired for FLAC\n-1 - automatic\nmin - 0 (fast encoding, large output file)\nmax - 10 (slow encoding, small output file)"));
+
+                  mFrameSizeSpin =  S.Id(FEFrameSizeID).TieSpinCtrl(_("Frame:"), wxT("/FileFormats/FFmpegFrameSize"), 0, 65535, 0);
+                  mFrameSizeSpin->SetToolTip(_("Frame size\nOptional\n0 - default\nmin - 16\nmax - 65535"));
+
+                  mLPCCoeffsPrecisionSpin = S.Id(FELPCCoeffsID).TieSpinCtrl(_("LPC"), wxT("/FileFormats/FFmpegLPCCoefPrec"), 0, 15, 0);
+                  mLPCCoeffsPrecisionSpin->SetToolTip(_("LPC coefficients precision\nOptional\n0 - default\nmin - 1\nmax - 15"));
+
+                  mPredictionOrderMethodChoice = S.Id(FEPredOrderID).TieChoice(_("PdO Method:"), wxT("/FileFormats/FFmpegPredOrderMethod"),
+                     mPredictionOrderMethodLabels[4], mPredictionOrderMethodNames, mPredictionOrderMethodLabels);
+                  mPredictionOrderMethodChoice->SetSizeHints( 100,-1);
+                  mPredictionOrderMethodChoice->SetToolTip(_("Prediction Order Method\nEstimate - fastest, lower compression\nLog search - slowest, best compression\nFull search - default"));
+
+                  mMinPredictionOrderSpin = S.Id(FEMinPredID).TieSpinCtrl(_("Min. PdO"), wxT("/FileFormats/FFmpegMinPredOrder"), -1, 32, -1);
+                  mMinPredictionOrderSpin->SetToolTip(_("Minimal prediction order\nOptional\n-1 - default\nmin - 0\nmax - 32 (with LPC) or 4 (without LPC)"));
+
+                  mMaxPredictionOrderSpin = S.Id(FEMaxPredID).TieSpinCtrl(_("Max. PdO"), wxT("/FileFormats/FFmpegMaxPredOrder"), -1, 32, -1);
+                  mMaxPredictionOrderSpin->SetToolTip(_("Maximal prediction order\nOptional\n-1 - default\nmin - 0\nmax - 32 (with LPC) or 4 (without LPC)"));
+
+                  mMinPartitionOrderSpin = S.Id(FEMinPartOrderID).TieSpinCtrl(_("Min. PtO"), wxT("/FileFormats/FFmpegMinPartOrder"), -1, 8, -1);
+                  mMinPartitionOrderSpin->SetToolTip(_("Minimal partition order\nOptional\n-1 - default\nmin - 0\nmax - 8"));
+
+                  mMaxPartitionOrderSpin = S.Id(FEMaxPartOrderID).TieSpinCtrl(_("Max. PtO"), wxT("/FileFormats/FFmpegMaxPredOrder"), -1, 8, -1);
+                  mMaxPartitionOrderSpin->SetToolTip(_("Maximal partition order\nOptional\n-1 - default\nmin - 0\nmax - 8"));
+
+                  S.AddVariableText(_("Use LPC"));
+                  S.Id(FEUseLPCID).TieCheckBox(wxEmptyString, wxT("/FileFormats/FFmpegUseLPC"), true);
+               }
+               S.EndMultiColumn();
+            }
+            S.EndStatic();
+            S.StartStatic(_("MPEG container options"),0);
+            {
+               S.StartMultiColumn(4, wxALIGN_LEFT);
+               {
+                  /* i18n-hint: 'mux' is short for multiplexor, a device that selects between several inputs
+                    'Mux Rate' is a parameter that has some bearing on compression ratio for MPEG
+                    it has a hard to predict effect on the degree of compression */
+                  mMuxRate = S.Id(FEMuxRateID).TieSpinCtrl(_("Mux Rate:"), wxT("/FileFormats/FFmpegMuxRate"), 0, 10000000, 0);
+                  mMuxRate->SetToolTip(_("Maximum bit rate of the multiplexed stream\nOptional\n0 - default"));
+
+                  /* i18n-hint: 'Packet Size' is a parameter that has some bearing on compression ratio for MPEG
+                    compression.  It measures how big a chunk of audio is compressed in one piece. */
+                  mPacketSize = S.Id(FEPacketSizeID).TieSpinCtrl(_("Packet Size:"), wxT("/FileFormats/FFmpegPacketSize"), 0, 10000000, 0);
+                  mPacketSize->SetToolTip(_("Packet size\nOptional\n0 - default"));
+               }
+               S.EndMultiColumn();
+            }
+            S.EndStatic();
+            //S.EndScroller();
+            S.SetBorder( 5 );
+            S.AddStandardButtons();
+         }
+         S.EndVerticalLay();
+      }
+      S.EndMultiColumn();
    }
    S.EndMultiColumn();
    S.EndVerticalLay();
@@ -1506,7 +1515,7 @@
 
 ///
 ///
-int ExportFFmpegOptions::FetchCompatibleCodecList(const wxChar *fmt, CodecID id)
+int ExportFFmpegOptions::FetchCompatibleCodecList(const wxChar *fmt, AVCodecID id)
 {
    // By default assume that id is not in the list
    int index = -1;
@@ -1524,16 +1533,16 @@
       {
          // Format is found in the list
          found = 1;
-         if (CompatibilityList[i].codec == CODEC_ID_NONE)
+         if (CompatibilityList[i].codec == AV_CODEC_ID_NONE)
          {
-            // Format is found in the list and it is compatible with CODEC_ID_NONE (means that it is compatible to anything)
+            // Format is found in the list and it is compatible with AV_CODEC_ID_NONE (means that it is compatible to anything)
             found = 2;
             break;
          }
          // Find the codec, that is claimed to be compatible
          AVCodec *codec = avcodec_find_encoder(CompatibilityList[i].codec);
          // If it exists, is audio and has encoder
-         if (codec != NULL && (codec->type == CODEC_TYPE_AUDIO) && codec->encode)
+         if (codec != NULL && (codec->type == AVMEDIA_TYPE_AUDIO) && av_codec_is_encoder(codec))
          {
             // If it was selected - remember it's new index
             if ((id >= 0) && codec->id == id) index = mShownCodecNames.GetCount();
@@ -1548,7 +1557,7 @@
       AVCodec *codec = NULL;
       while ((codec = av_codec_next(codec)))
       {
-         if (codec->type == CODEC_TYPE_AUDIO && codec->encode)
+         if (codec->type == AVMEDIA_TYPE_AUDIO && av_codec_is_encoder(codec))
          {
             if (mShownCodecNames.Index(wxString::FromUTF8(codec->name)) < 0)
             {
@@ -1568,7 +1577,7 @@
       if (format != NULL)
       {
          AVCodec *codec = avcodec_find_encoder(format->audio_codec);
-         if (codec != NULL && (codec->type == CODEC_TYPE_AUDIO) && codec->encode)
+         if (codec != NULL && (codec->type == AVMEDIA_TYPE_AUDIO) && av_codec_is_encoder(codec))
          {
             if ((id >= 0) && codec->id == id) index = mShownCodecNames.GetCount();
             mShownCodecNames.Add(wxString::FromUTF8(codec->name));
@@ -1584,7 +1593,7 @@
 
 ///
 ///
-int ExportFFmpegOptions::FetchCompatibleFormatList(CodecID id, wxString *selfmt)
+int ExportFFmpegOptions::FetchCompatibleFormatList(AVCodecID id, wxString *selfmt)
 {
    int index = -1;
    mShownFormatNames.Clear();
@@ -1596,7 +1605,7 @@
    // Find all formats compatible to this codec in compatibility list
    for (int i = 0; CompatibilityList[i].fmt != NULL; i++)
    {
-      if (CompatibilityList[i].codec == id || CompatibilityList[i].codec == CODEC_ID_NONE)
+      if (CompatibilityList[i].codec == id || CompatibilityList[i].codec == AV_CODEC_ID_NONE)
       {
          if ((selfmt != NULL) && (selfmt->Cmp(CompatibilityList[i].fmt) == 0)) index = mShownFormatNames.GetCount();
          FromList.Add(CompatibilityList[i].fmt);
@@ -1778,7 +1787,7 @@
       {
          bool codec = false;
          bool format = false;
-         if (apptable[i].codec == CODEC_ID_NONE) codec = true;
+         if (apptable[i].codec == AV_CODEC_ID_NONE) codec = true;
          else if (cdc != NULL && apptable[i].codec == cdc->id) codec = true;
          if (!wxString::FromUTF8(apptable[i].format).Cmp(wxT("any"))) format = true;
          else if (selfmt != NULL && selfmt->Cmp(wxString::FromUTF8(apptable[i].format)) == 0) format = true;
@@ -1824,7 +1833,7 @@
          selcdcid = cdc->id;
       }
    }
-   int newselcdc = FetchCompatibleCodecList(selfmt->c_str(), (CodecID)selcdcid);
+   int newselcdc = FetchCompatibleCodecList(selfmt->c_str(), (AVCodecID)selcdcid);
    if (newselcdc >= 0) mCodecList->Select(newselcdc);
 
    AVCodec *cdc = NULL;
@@ -1898,7 +1907,7 @@
 {
    int selcdc = mCodecList->GetSelection();
    int selfmt = mFormatList->GetSelection();
-   if (selcdc > -1) gPrefs->Write(wxT("/FileFormats/FFmpegCodec"),(long)avcodec_find_encoder_by_name(mCodecList->GetString(selcdc).ToUTF8())->id);
+   if (selcdc > -1) gPrefs->Write(wxT("/FileFormats/FFmpegCodec"),mCodecList->GetString(selcdc));
    if (selfmt > -1) gPrefs->Write(wxT("/FileFormats/FFmpegFormat"),mFormatList->GetString(selfmt));
    gPrefs->Flush();
    ShuttleGui S(this, eIsSavingToPrefs);
--- a/src/export/ExportFFmpegDialogs.h
+++ b/src/export/ExportFFmpegDialogs.h
@@ -43,7 +43,7 @@
    int canmetadata;           //!< !=0 if format supports metadata, -1 any avformat version, otherwise version support added
    bool canutf8;              //!< true if format supports metadata in UTF-8, false otherwise
    const wxChar *description; //!< format description (will be shown in export dialog)
-   CodecID codecid;           //!< codec ID (see libavcodec/avcodec.h)
+   AVCodecID codecid;         //!< codec ID (see libavcodec/avcodec.h)
    bool compiledIn;           //!< support for this codec/format is compiled in (checked at runtime)
 };
 
@@ -52,7 +52,7 @@
 struct CompatibilityEntry
 {
    const wxChar *fmt; //!< format, recognizeable by guess_format()
-   CodecID codec;     //!< codec ID
+   AVCodecID codec;   //!< codec ID
 };
 
 
@@ -148,7 +148,7 @@
 {
    bool                 enable;  //!< true if this control should be enabled, false otherwise
    int                  control; //!< control ID
-   CodecID              codec;   //!< Codec ID
+   AVCodecID            codec;   //!< Codec ID
    const char          *format;  //!< Format short name
 };
 
@@ -258,7 +258,7 @@
    ///\param id Codec ID
    ///\param selfmt format selected at the moment
    ///\return index of the selfmt in new format list or -1 if it is not in the list
-   int FetchCompatibleFormatList(CodecID id, wxString *selfmt);
+   int FetchCompatibleFormatList(AVCodecID id, wxString *selfmt);
 
    /// Retreives codec list from libavcodec
    void FetchCodecList();
@@ -267,7 +267,7 @@
    ///\param fmt Format short name
    ///\param id id of the codec selected at the moment
    ///\return index of the id in new codec list or -1 if it is not in the list
-   int FetchCompatibleCodecList(const wxChar *fmt, CodecID id);
+   int FetchCompatibleCodecList(const wxChar *fmt, AVCodecID id);
 
    /// Retreives list of presets from configuration file
    void FetchPresetList();
--- a/src/import/ImportFFmpeg.cpp
+++ b/src/import/ImportFFmpeg.cpp
@@ -37,7 +37,7 @@
 //TODO: remove non-audio extensions
 #if defined(USE_FFMPEG)
 static const wxChar *exts[] =
-{   
+{
    wxT("4xm"),
    wxT("MTV"),
    wxT("roq"),
@@ -171,7 +171,7 @@
    FFmpegImportPlugin():
       ImportPlugin(wxArrayString(WXSIZEOF(exts),exts))
       {
-         
+
       }
 
    ~FFmpegImportPlugin() { }
@@ -210,23 +210,23 @@
    ///! Reads next audio frame
    ///\return pointer to the stream context structure to which the frame belongs to or NULL on error, or 1 if stream is not to be imported.
    streamContext* ReadNextFrame();
-   
+
    ///! Decodes the frame
    ///\param sc - stream context (from ReadNextFrame)
    ///\param flushing - true if flushing (no more frames left), false otherwise
    ///\return 0 on success, -1 if it can't decode any further
    int DecodeFrame(streamContext *sc, bool flushing);
-   
+
    ///! Writes decoded data into WaveTracks. Called by DecodeFrame
    ///\param sc - stream context
    ///\return 0 on success, 1 on error or interruption
    int WriteData(streamContext *sc);
-   
+
    ///! Writes extracted metadata to tags object
    ///\param avf - file context
    ///\ tags - Audacity tags object
    void WriteMetadata(Tags *tags);
-   
+
    ///! Retrieves metadata from FFmpeg and converts to wxString
    ///\param avf - file context
    ///\ tags - Audacity tags object
@@ -240,7 +240,7 @@
    {
       return mNumStreams;
    }
-   
+
    ///! Called by Import.cpp
    ///\return array of strings - descriptions of the streams
    wxArrayString *GetStreamInfo()
@@ -263,7 +263,7 @@
    int                   mNumStreams;    //!< mNumstreams is less or equal to mFormatContext->nb_streams
    streamContext       **mScs;           //!< Array of pointers to stream contexts. Length is mNumStreams.
    wxArrayString        *mStreamInfo;    //!< Array of stream descriptions. Length is mNumStreams
-   
+
    wxInt64               mProgressPos;   //!< Current timestamp, file position or whatever is used as first argument for Update()
    wxInt64               mProgressLen;   //!< Duration, total length or whatever is used as second argument for Update()
 
@@ -317,7 +317,7 @@
             dlg = new FFmpegNotFoundDialog(NULL);
             dlg->ShowModal();
             delete dlg;
-         }         
+         }
       }
    }
    if (!FFmpegLibsInst->ValidLibsLoaded())
@@ -326,7 +326,7 @@
       return NULL;
    }
 
-   // Open the file for import  
+   // Open the file for import
    bool success = handle->Init();
    if (!success) {
       delete handle;
@@ -369,10 +369,10 @@
       return false;
    }
 
-   err = av_find_stream_info(mFormatContext);
+   err = avformat_find_stream_info(mFormatContext, NULL);
    if (err < 0)
    {
-      wxLogError(wxT("FFmpeg : av_find_stream_info() failed for file %s"),mName.c_str());
+      wxLogError(wxT("FFmpeg: avformat_find_stream_info() failed for file %s"),mName.c_str());
       return false;
    }
 
@@ -388,7 +388,7 @@
    // Fill the stream contexts
    for (unsigned int i = 0; i < mFormatContext->nb_streams; i++)
    {
-      if (mFormatContext->streams[i]->codec->codec_type == CODEC_TYPE_AUDIO)
+      if (mFormatContext->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO)
       {
          //Create a context
          streamContext *sc = new streamContext;
@@ -413,7 +413,7 @@
             continue;
          }
 
-         if (avcodec_open(sc->m_codecCtx, codec) < 0)
+         if (avcodec_open2(sc->m_codecCtx, codec, NULL) < 0)
          {
             wxLogError(wxT("FFmpeg : avcodec_open() failed. Index[%02d], Codec[%02x - %s]"),i,sc->m_codecCtx->codec_id,sc->m_codecCtx->codec_name);
             //Can't open decoder - skip this stream
@@ -425,16 +425,16 @@
          wxString strinfo;
          int duration = 0;
          if (sc->m_stream->duration > 0)
-           duration = sc->m_stream->duration * sc->m_stream->time_base.num / sc->m_stream->time_base.den;
+            duration = sc->m_stream->duration * sc->m_stream->time_base.num / sc->m_stream->time_base.den;
          else
-           duration = mFormatContext->duration / AV_TIME_BASE;
+            duration = mFormatContext->duration / AV_TIME_BASE;
          wxString bitrate = wxT("");
          if (sc->m_codecCtx->bit_rate > 0)
-           bitrate.Printf(wxT("%d"),sc->m_codecCtx->bit_rate);
+            bitrate.Printf(wxT("%d"),sc->m_codecCtx->bit_rate);
          else
-           bitrate.Printf(wxT("?"));
+            bitrate.Printf(wxT("?"));
 
-         AVMetadataTag *tag = av_metadata_get(sc->m_stream->metadata, "language", NULL, 0);
+         AVDictionaryEntry *tag = av_dict_get(sc->m_stream->metadata, "language", NULL, 0);
          wxString lang;
          if (tag)
          {
@@ -491,8 +491,10 @@
    {
       switch (mScs[s]->m_stream->codec->sample_fmt)
       {
-         case SAMPLE_FMT_U8:
-         case SAMPLE_FMT_S16:
+         case AV_SAMPLE_FMT_U8:
+         case AV_SAMPLE_FMT_S16:
+         case AV_SAMPLE_FMT_U8P:
+         case AV_SAMPLE_FMT_S16P:
             mScs[s]->m_osamplesize = sizeof(int16_t);
             mScs[s]->m_osamplefmt = int16Sample;
          break;
@@ -574,24 +576,24 @@
             sampleDuration = ((sampleCount)mFormatContext->duration *mScs[s]->m_stream->codec->sample_rate) / AV_TIME_BASE;
 
          //      printf(" OD duration samples %qi, sr %d, secs %d\n",sampleDuration, (int)mScs[s]->m_stream->codec->sample_rate,(int)sampleDuration/mScs[s]->m_stream->codec->sample_rate);
-         
+
          //for each wavetrack within the stream add coded blockfiles
          for (int c = 0; c < mScs[s]->m_stream->codec->channels; c++) {
             WaveTrack *t = mChannels[s][c];
             odTask->AddWaveTrack(t);
-         
+
             sampleCount maxBlockSize = t->GetMaxBlockSize();
             //use the maximum blockfile size to divide the sections (about 11secs per blockfile at 44.1khz)
             for (sampleCount i = 0; i < sampleDuration; i += maxBlockSize) {
                sampleCount blockLen = maxBlockSize;
                if (i + blockLen > sampleDuration)
                   blockLen = sampleDuration - i;
-            
+
                t->AppendCoded(mFilename, i, blockLen, c,ODTask::eODFFMPEG);
-            
-               // This only works well for single streams since we assume 
+
+               // This only works well for single streams since we assume
                // each stream is of the same duration and channels
-               res = mProgress->Update(i+sampleDuration*c+ sampleDuration*mScs[s]->m_stream->codec->channels*s, 
+               res = mProgress->Update(i+sampleDuration*c+ sampleDuration*mScs[s]->m_stream->codec->channels*s,
                                        sampleDuration*mScs[s]->m_stream->codec->channels*mNumStreams);
                if (res != eProgressSuccess)
                   break;
@@ -634,7 +636,7 @@
          {
             av_free_packet(&sc->m_pkt);
             sc->m_pktValid = 0;
-         }    
+         }
       }
    }
 
@@ -651,7 +653,7 @@
             {
                av_free_packet(&mScs[i]->m_pkt);
                mScs[i]->m_pktValid = 0;
-            }               
+            }
          }
       }
    }
@@ -749,23 +751,28 @@
          {
             switch (sc->m_samplefmt)
             {
-               case SAMPLE_FMT_U8:
+               case AV_SAMPLE_FMT_U8:
+               case AV_SAMPLE_FMT_U8P:
                   ((int16_t *)tmp[chn])[index] = (int16_t) (*(uint8_t *)in - 0x80) << 8;
                break;
-               
-               case SAMPLE_FMT_S16:
+
+               case AV_SAMPLE_FMT_S16:
+               case AV_SAMPLE_FMT_S16P:
                   ((int16_t *)tmp[chn])[index] = (int16_t) *(int16_t *)in;
                break;
-               
-               case SAMPLE_FMT_S32:
+
+               case AV_SAMPLE_FMT_S32:
+               case AV_SAMPLE_FMT_S32P:
                   ((float *)tmp[chn])[index] = (float) *(int32_t *)in * (1.0 / (1 << 31));
                break;
-               
-               case SAMPLE_FMT_FLT:
+
+               case AV_SAMPLE_FMT_FLT:
+               case AV_SAMPLE_FMT_FLTP:
                   ((float *)tmp[chn])[index] = (float) *(float *)in;
                break;
-               
-               case SAMPLE_FMT_DBL:
+
+               case AV_SAMPLE_FMT_DBL:
+               case AV_SAMPLE_FMT_DBLP:
                   ((float *)tmp[chn])[index] = (float) *(double *)in;
                break;
 
@@ -789,9 +796,10 @@
    }
 
    free(tmp);
-   
+
    // Try to update the progress indicator (and see if user wants to cancel)
    int updateResult = eProgressSuccess;
+   int64_t filesize = avio_size(mFormatContext->pb);
    // PTS (presentation time) is the proper way of getting current position
    if (sc->m_pkt.pts != int64_t(AV_NOPTS_VALUE) && mFormatContext->duration != int64_t(AV_NOPTS_VALUE))
    {
@@ -805,10 +813,10 @@
       mProgressLen = sc->m_stream->nb_frames;
    }
    // When number of frames is unknown, use position in file
-   else if (mFormatContext->file_size > 0 && sc->m_pkt.pos > 0 && sc->m_pkt.pos <= mFormatContext->file_size)
+   else if (filesize > 0 && sc->m_pkt.pos > 0 && sc->m_pkt.pos <= filesize)
    {
       mProgressPos = sc->m_pkt.pos;
-      mProgressLen = mFormatContext->file_size;
+      mProgressLen = filesize;
    }
    updateResult = mProgress->Update(mProgressPos, mProgressLen != 0 ? mProgressLen : 1);
 
@@ -831,9 +839,9 @@
 
 void FFmpegImportFileHandle::GetMetadata(Tags *tags, const wxChar *tag, const char *name)
 {
-   AVMetadataTag *meta;
+   AVDictionaryEntry *meta;
 
-   meta = av_metadata_get(mFormatContext->metadata, name, NULL, AV_METADATA_IGNORE_SUFFIX);
+   meta = av_dict_get(mFormatContext->metadata, name, NULL, AV_DICT_IGNORE_SUFFIX);
    if (meta)
    {
       tags->SetTag(tag, wxString::FromUTF8(meta->value));
@@ -850,7 +858,7 @@
 #endif
    if (FFmpegLibsInst->ValidLibsLoaded())
    {
-      if (mFormatContext) av_close_input_file(mFormatContext);
+      if (mFormatContext) avformat_close_input(&mFormatContext);
       av_log_set_callback(av_log_default_callback);
    }
 
