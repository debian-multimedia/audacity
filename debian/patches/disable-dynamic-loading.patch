Description: Add configure option to disable dynamic loading of FFmpeg
 This patch also adds support for FFmpeg >= 0.6
Author: Benjamin Drung <bdrung@ubuntu.com>
Bug: http://bugzilla.audacityteam.org/show_bug.cgi?id=233

--- audacity-1.3.12.orig/configure.in
+++ audacity-1.3.12/configure.in
@@ -138,7 +138,7 @@ AC_DEFINE(BUILDING_AUDACITY, 1,
 # plug-ins. This might not work on all architectures / compilers, so we need
 # to check if it does or not.
 AX_LD_CHECK_FLAG([-rdynamic],[],[],
-               have_dynamic_link=yes,have_dynamic_link=no)
+               [have_dynamic_link=yes],[have_dynamic_link=no])
 if test "x$have_dynamic_link" = "xyes" ; then
    BUILD_LDFLAGS="${BUILD_LDFLAGS} -rdynamic "
 else
@@ -173,6 +173,12 @@ AC_ARG_WITH(lib-preference,
             lib_preference=$withval,
             lib_preference="system local")
 
+AC_ARG_ENABLE(dynamic-loading,
+            [AS_HELP_STRING([--enable-dynamic-loading],
+                            [enable dynamic loading of lame and FFmpeg [default=yes]])],
+            [dynamic_loading="$enableval"],
+            [dynamic_loading="yes"])
+
 dnl AC_ARG_WITH(wx-version,
 dnl            [AS_HELP_STRING([--with-wx-version],
 dnl                            [select wxWidgets version (if both installed) [2.8,]])],
@@ -286,7 +292,7 @@ dnl LOCAL_LIBS="$LOCAL_LIBS allegro.a"
 dnl CXXFLAGS="$CXXFLAGS -I\$(top_srcdir)/lib-src/allegro"
 
 dnl Include FileDialog
-AC_CONFIG_SUBDIRS(["lib-src/FileDialog"])
+AC_CONFIG_SUBDIRS([lib-src/FileDialog])
 LOCAL_LIBS="$LOCAL_LIBS FileDialog.a"
 CXXFLAGS="$CXXFLAGS -I\$(top_srcdir)/lib-src/FileDialog"
 
--- /dev/null
+++ audacity-1.3.12/autogen.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+aclocal -I m4
+autoconf
+rm -rf aclocal.m4 autom4te.cache
--- audacity-1.3.12.orig/m4/audacity_checklib_ffmpeg.m4
+++ audacity-1.3.12/m4/audacity_checklib_ffmpeg.m4
@@ -2,7 +2,7 @@ dnl Todo: Add Audacity / FFmpeg license
 dnl
 dnl Please increment the serial number below whenever you alter this macro
 dnl for the benefit of automatic macro update systems
-# audacity_checklib_ffmpeg.m4 serial 1
+# audacity_checklib_ffmpeg.m4 serial 2
 dnl Check for a copy of ffmpeg, whoose headers we will use for the importer
 AC_DEFUN([AUDACITY_CHECKLIB_FFMPEG], [
    AC_ARG_WITH(ffmpeg,
@@ -33,6 +33,10 @@ AC_DEFUN([AUDACITY_CHECKLIB_FFMPEG], [
 	     FFMPEG_SYSTEM_AVAILABLE="yes"
          FFMPEG_SYSTEM_CXXFLAGS="$AVCODEC_CFLAGS $AVFORMAT_CFLAGS"
          FFMPEG_SYSTEM_CPPSYMBOLS="USE_FFMPEG"
+	     if test "x$dynamic_loading" = "xno"; then
+	        FFMPEG_SYSTEM_LIBS="$AVCODEC_LIBS $AVFORMAT_LIBS"
+	        AC_DEFINE(USE_SYSTEM_FFMPEG, 1, [Use system FFmpeg library and disable dynamic loading of it.])
+	     fi
 		 dnl build the extra object files needed to use FFmpeg. Paths inside
 		 dnl the audacity src/ dir, as this is subsitiuted into src/Makefile.in
 		 FFMPEG_SYSTEM_OPTOBJS="import/ImportFFmpeg.o export/ExportFFmpeg.o \
--- audacity-1.3.12.orig/src/FFmpeg.cpp
+++ audacity-1.3.12/src/FFmpeg.cpp
@@ -40,6 +40,8 @@ wxString GetFFmpegVersion(wxWindow *pare
 
 #else
 
+#ifndef USE_SYSTEM_FFMPEG
+
 /** This pointer to the shared object has global scope and is used to track the
  * singleton object which wraps the FFmpeg codecs */
 FFmpegLibs *FFmpegLibsInst = NULL;
@@ -122,6 +124,8 @@ wxString GetFFmpegVersion(wxWindow *pare
    return versionString;
 }
 
+#endif // USE_SYSTEM_FFMPEG
+
 void av_log_wx_callback(void* ptr, int level, const char* fmt, va_list vl)
 {
    //Most of this stuff is taken from FFmpeg tutorials and FFmpeg itself
@@ -204,7 +208,12 @@ static int ufile_read(URLContext *h, uns
    return ret;
 }
 
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 68, 0)
 static int ufile_write(URLContext *h, unsigned char *buf, int size)
+#else
+static int ufile_write(URLContext *h, const unsigned char *buf, int size)
+#endif
+
 {
    return (int) ((wxFile *) h->priv_data)->Write(buf, size);
 }
@@ -265,15 +274,15 @@ int ufile_fopen(ByteIOContext **s, const
    // Open the file using our custom protocol and passing the (possibly) Unicode
    // filename.  This is playing a slight trick since our ufile_open() routine above
    // knows that the "char *" name may actually be wide characters.
-   err = FFmpegLibsInst->url_open_protocol(&h, &ufile_protocol, (const char *) name.c_str(), flags);
+   err = FFMPEG_LIB(url_open_protocol(&h, &ufile_protocol, (const char *) name.c_str(), flags));
    if (err < 0) {
       return err;
    }
 
    // Associate the file with a context
-   err = FFmpegLibsInst->url_fdopen(s, h);
+   err = FFMPEG_LIB(url_fdopen(s, h));
    if (err < 0) {
-      FFmpegLibsInst->url_close(h);
+      FFMPEG_LIB(url_close(h));
       return err;
    }
 
@@ -307,7 +316,7 @@ int ufile_fopen_input(AVFormatContext **
    // Initialize probe data...go ahead and preallocate the maximum buffer size.
    pd.filename = filename;
    pd.buf_size = 0;
-   pd.buf = (unsigned char *) FFmpegLibsInst->av_malloc(PROBE_BUF_MAX + AVPROBE_PADDING_SIZE);
+   pd.buf = (unsigned char *) FFMPEG_LIB(av_malloc(PROBE_BUF_MAX + AVPROBE_PADDING_SIZE));
    if (pd.buf == NULL) {
       err = AVERROR_NOMEM;
       goto fail;
@@ -322,7 +331,7 @@ int ufile_fopen_input(AVFormatContext **
       int score_max = probe_size < PROBE_BUF_MAX ? AVPROBE_SCORE_MAX / 4 : 0;
 
       // Read up to a "probe_size" worth of data
-      pd.buf_size = FFmpegLibsInst->get_buffer(pb, pd.buf, probe_size);
+      pd.buf_size = FFMPEG_LIB(get_buffer(pb, pd.buf, probe_size));
 
       // AWD: with zero-length input files buf_size can come back negative;
       // this causes problems so we might as well just fail
@@ -335,14 +344,14 @@ int ufile_fopen_input(AVFormatContext **
       memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);
 
       // Reposition file for succeeding scan
-      if (FFmpegLibsInst->url_fseek(pb, 0, SEEK_SET) < 0) {
+      if (FFMPEG_LIB(url_fseek(pb, 0, SEEK_SET)) < 0) {
          err = AVERROR(EIO);
          goto fail;
       }
 
       // Scan all input formats
       fmt = NULL;
-      for (fmt1 = FFmpegLibsInst->av_iformat_next(NULL); fmt1 != NULL; fmt1 = FFmpegLibsInst->av_iformat_next(fmt1)) {
+      for (fmt1 = FFMPEG_LIB(av_iformat_next(NULL)); fmt1 != NULL; fmt1 = FFMPEG_LIB(av_iformat_next(fmt1))) {
          int score = 0;
 
          // Ignore the ones that are not file based
@@ -356,7 +365,11 @@ int ufile_fopen_input(AVFormatContext **
          }
          // Otherwize, resort to extension matching if available
          else if (fmt1->extensions) {
-            if (FFmpegLibsInst->match_ext(filename, fmt1->extensions)) {
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 60, 0)
+            if (FFMPEG_LIB(match_ext(filename, fmt1->extensions))) {
+#else
+            if (FFMPEG_LIB(av_match_ext(filename, fmt1->extensions))) {
+#endif
                score = 50;
             }
          }
@@ -379,23 +392,23 @@ int ufile_fopen_input(AVFormatContext **
    }
 
    // And finally, attempt to associate an input stream with the file
-   err = FFmpegLibsInst->av_open_input_stream(ic_ptr, pb, filename, fmt, NULL);
+   err = FFMPEG_LIB(av_open_input_stream(ic_ptr, pb, filename, fmt, NULL));
    if (err) {
       goto fail;
    }
 
    // Done with the probe buffer
-   FFmpegLibsInst->av_freep(&pd.buf);
+   FFMPEG_LIB(av_freep(&pd.buf));
 
    return 0;
 
 fail:
    if (pd.buf) {
-      FFmpegLibsInst->av_freep(&pd.buf);
+      FFMPEG_LIB(av_freep(&pd.buf));
    }
 
    if (pb) {
-      FFmpegLibsInst->url_fclose(pb);
+      FFMPEG_LIB(url_fclose(pb));
    }
 
    *ic_ptr = NULL;
@@ -405,6 +418,8 @@ fail:
 
 /*******************************************************/
 
+#ifndef USE_SYSTEM_FFMPEG
+
 class FFmpegNotFoundDialog;
 
 //----------------------------------------------------------------------------
@@ -820,8 +835,13 @@ bool FFmpegLibs::InitLibs(wxString libpa
    INITDYN(avformat,url_fclose);
    INITDYN(avformat,url_fsize);
    INITDYN(avformat,av_new_stream);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
    INITDYN(avformat,av_alloc_format_context);
    INITDYN(avformat,guess_format);
+#else
+   INITDYN(avformat,avformat_alloc_context);
+   INITDYN(avformat,av_guess_format);
+#endif
    INITDYN(avformat,av_write_trailer);
    INITDYN(avformat,av_codec_get_id);
    INITDYN(avformat,av_codec_get_tag);
@@ -829,7 +849,11 @@ bool FFmpegLibs::InitLibs(wxString libpa
    INITDYN(avformat,av_open_input_file);
    INITDYN(avformat,av_open_input_stream);
    INITDYN(avformat,get_buffer);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 60, 0)
    INITDYN(avformat,match_ext);
+#else
+   INITDYN(avformat,av_match_ext);
+#endif
 
 #if FFMPEG_STABLE
    INITDYN(avformat,av_init_packet);
@@ -939,4 +963,6 @@ void FFmpegLibs::FreeLibs()
    return;
 }
 
+#endif // USE_SYSTEM_FFMPEG
+
 #endif //USE_FFMPEG
--- audacity-1.3.12.orig/src/FFmpeg.h
+++ audacity-1.3.12/src/FFmpeg.h
@@ -90,6 +90,13 @@ int modify_file_url_to_utf8(char* buffer
 int modify_file_url_to_utf8(char* buffer, size_t buffer_size, const wchar_t* url);
 #endif
 
+
+#ifdef USE_SYSTEM_FFMPEG
+#define FFMPEG_LIB(x) x
+#else //USE_SYSTEM_FFMPEG
+
+#define FFMPEG_LIB(x) FFmpegLibsInst->x
+
 //----------------------------------------------------------------------------
 // Attempt to load and enable/disable FFmpeg at startup
 //----------------------------------------------------------------------------
@@ -222,9 +229,18 @@ public:
    int               (*url_fclose)                    (ByteIOContext *s);
    int               (*url_fsize)                     (ByteIOContext *s);
    AVStream*         (*av_new_stream)                 (AVFormatContext *s, int id);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
    AVFormatContext*  (*av_alloc_format_context)       (void);
    AVOutputFormat*   (*guess_format)                  (const char *short_name, const char *filename, const char *mime_type);
+#else
+   AVFormatContext*  (*avformat_alloc_context)        (void);
+   AVOutputFormat*   (*av_guess_format)               (const char *short_name, const char *filename, const char *mime_type);
+#endif
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 60, 0)
    int               (*match_ext)                     (const char *filename, const char *extensions);
+#else
+   int               (*av_match_ext)                  (const char *filename, const char *extensions);
+#endif
    int               (*av_write_trailer)              (AVFormatContext *s);
    int               (*av_interleaved_write_frame)    (AVFormatContext *s, AVPacket *pkt);
    int               (*av_write_frame)                (AVFormatContext *s, AVPacket *pkt);
@@ -396,6 +412,10 @@ FFmpegLibs *PickFFmpegLibs();
 ///! anymore, or just decrements it's reference count
 void        DropFFmpegLibs();
 
+extern FFmpegLibs *FFmpegLibsInst;
+
+#endif // USE_SYSTEM_FFMPEG
+
 int ufile_fopen(ByteIOContext **s, const wxString & name, int flags);
 int ufile_fopen_input(AVFormatContext **ic_ptr, wxString & name);
 
--- audacity-1.3.12.orig/src/configtemplate.h
+++ audacity-1.3.12/src/configtemplate.h
@@ -84,6 +84,9 @@
    */
 #undef USE_FFMPEG
 
+/* Use system FFmpeg library and disable dynamic loading of it. */
+#undef USE_SYSTEM_FFMPEG
+
 /* Define if LADSPA plug-ins are enabled */
 #undef USE_LADSPA
 
--- audacity-1.3.12.orig/src/AudacityApp.cpp
+++ audacity-1.3.12/src/AudacityApp.cpp
@@ -1117,7 +1117,13 @@ bool AudacityApp::OnInit()
    mLogger->SetLogLevel(wxLOG_Max);
 
    #ifdef USE_FFMPEG
+   #ifdef USE_SYSTEM_FFMPEG
+   avcodec_init();
+   avcodec_register_all();
+   av_register_all();
+   #else //USE_SYSTEM_FFMPEG
    FFmpegStartup();
+   #endif //USE_SYSTEM_FFMPEG
    #endif
 
    #ifdef USE_GSTREAMER
@@ -1707,7 +1713,9 @@ int AudacityApp::OnExit()
    FinishPreferences();
 
    #ifdef USE_FFMPEG
+   #ifndef USE_SYSTEM_FFMPEG
    DropFFmpegLibs();
+   #endif //USE_SYSTEM_FFMPEG
    #endif
 
    UnloadEffects();
--- audacity-1.3.12.orig/src/export/ExportFFmpeg.cpp
+++ audacity-1.3.12/src/export/ExportFFmpeg.cpp
@@ -50,8 +50,7 @@ function.
 
 #if defined(USE_FFMPEG)
 
-extern FFmpegLibs *FFmpegLibsInst;
-
+#ifndef USE_SYSTEM_FFMPEG
 static bool CheckFFmpegPresence()
 {
    bool result = true;
@@ -64,6 +63,7 @@ static bool CheckFFmpegPresence()
    DropFFmpegLibs();
    return result;
 }
+#endif //USE_SYSTEM_FFMPEG
 
 static int AdjustFormatIndex(int format)
 {
@@ -178,18 +178,28 @@ ExportFFmpeg::ExportFFmpeg()
    mSampleRate = 0;
    mSupportsUTF8 = true;
 
+#ifndef USE_SYSTEM_FFMPEG
    PickFFmpegLibs(); // DropFFmpegLibs() call is in ExportFFmpeg::Destroy()
+#endif //USE_SYSTEM_FFMPEG
    int newfmt;
    // Adds export types from the export type list
    for (newfmt = 0; newfmt < FMT_LAST; newfmt++)
    {
       wxString shortname(ExportFFmpegOptions::fmts[newfmt].shortname);
       //Don't hide export types when there's no av-libs, and don't hide FMT_OTHER
+#ifdef USE_SYSTEM_FFMPEG
+      if (newfmt < FMT_OTHER)
+#else
       if (newfmt < FMT_OTHER && FFmpegLibsInst->ValidLibsLoaded())
+#endif //USE_SYSTEM_FFMPEG
       {
          // Format/Codec support is compiled in?
-         AVOutputFormat *avoformat = FFmpegLibsInst->guess_format(shortname.mb_str(), NULL, NULL);
-         AVCodec *avcodec = FFmpegLibsInst->avcodec_find_encoder(ExportFFmpegOptions::fmts[newfmt].codecid);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+         AVOutputFormat *avoformat = FFMPEG_LIB(guess_format(shortname.mb_str(), NULL, NULL));
+#else
+         AVOutputFormat *avoformat = FFMPEG_LIB(av_guess_format(shortname.mb_str(), NULL, NULL));
+#endif
+         AVCodec *avcodec = FFMPEG_LIB(avcodec_find_encoder(ExportFFmpegOptions::fmts[newfmt].codecid));
          if (avoformat == NULL || avcodec == NULL)
          {
             ExportFFmpegOptions::fmts[newfmt].compiledIn = false;
@@ -223,7 +233,9 @@ ExportFFmpeg::ExportFFmpeg()
 
 void ExportFFmpeg::Destroy()
 {
+#ifndef USE_SYSTEM_FFMPEG
    DropFFmpegLibs();
+#endif //USE_SYSTEM_FFMPEG
    delete this;
 }
 
@@ -239,10 +251,12 @@ bool ExportFFmpeg::CheckFileName(wxFileN
    }
    else
 #endif
+#ifndef USE_SYSTEM_FFMPEG
    if (!CheckFFmpegPresence())
    {
       result = false;
    }
+#endif //USE_SYSTEM_FFMPEG
    return result;
 }
 
@@ -251,23 +265,33 @@ bool ExportFFmpeg::Init(const char *shor
    int err;
    //FFmpegLibsInst->LoadLibs(NULL,true); //Loaded at startup or from Prefs now
 
+#ifndef USE_SYSTEM_FFMPEG
    if (!FFmpegLibsInst->ValidLibsLoaded()) return false;
+#endif //USE_SYSTEM_FFMPEG
 
-   FFmpegLibsInst->av_log_set_callback(av_log_wx_callback);
+   FFMPEG_LIB(av_log_set_callback(av_log_wx_callback));
 
    AVFormatParameters	fpOutFile;
 
    // See if libavformat has modules that can write our output format. If so, mEncFormatDesc
    // will describe the functions used to write the format (used internally by libavformat)
    // and the default video/audio codecs that the format uses.
-   if ((mEncFormatDesc = FFmpegLibsInst->guess_format(shortname, OSINPUT(mName), NULL)) == NULL)
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+   if ((mEncFormatDesc = FFMPEG_LIB(guess_format(shortname, OSINPUT(mName), NULL))) == NULL)
+#else
+   if ((mEncFormatDesc = FFMPEG_LIB(av_guess_format(shortname, OSINPUT(mName), NULL))) == NULL)
+#endif
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't determine format description for file \"%s\"."), mName.c_str());
       return false;
    }
 
    // mEncFormatCtx is used by libavformat to carry around context data re our output file.
-   if ((mEncFormatCtx = FFmpegLibsInst->av_alloc_format_context()) == NULL)
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+   if ((mEncFormatCtx = FFMPEG_LIB(av_alloc_format_context())) == NULL)
+#else
+   if ((mEncFormatCtx = FFMPEG_LIB(avformat_alloc_context())) == NULL)
+#endif
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't allocate output format context."));
       return false;
@@ -278,7 +302,7 @@ bool ExportFFmpeg::Init(const char *shor
    memcpy(mEncFormatCtx->filename, OSINPUT(mName), strlen(OSINPUT(mName))+1);
    
    // At the moment Audacity can export only one audio stream
-   if ((mEncAudioStream = FFmpegLibsInst->av_new_stream(mEncFormatCtx, 1)) == NULL)
+   if ((mEncAudioStream = FFMPEG_LIB(av_new_stream(mEncFormatCtx, 1))) == NULL)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't add audio stream to output file \"%s\"."), mName.c_str());
       return false;
@@ -299,7 +323,7 @@ bool ExportFFmpeg::Init(const char *shor
 
    // Set default parameters on the format context.
    memset(&fpOutFile, 0, sizeof(AVFormatParameters));
-   if ((err = FFmpegLibsInst->av_set_parameters(mEncFormatCtx, &fpOutFile)) < 0)
+   if ((err = FFMPEG_LIB(av_set_parameters(mEncFormatCtx, &fpOutFile))) < 0)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't set output parameters for output file \"%s\". Error code is %d."), mName.c_str(),err);
       return false;
@@ -324,7 +348,7 @@ bool ExportFFmpeg::Init(const char *shor
    }
 
    // Write headers to the output file.
-   if ((err = FFmpegLibsInst->av_write_header(mEncFormatCtx)) < 0)
+   if ((err = FFMPEG_LIB(av_write_header(mEncFormatCtx))) < 0)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't write headers to output file \"%s\". Error code is %d."), mName.c_str(),err);
 
@@ -349,11 +373,11 @@ bool ExportFFmpeg::InitCodecs(AudacityPr
    // Configure the audio stream's codec context.
    mEncAudioCodecCtx = mEncAudioStream->codec;
   
-   FFmpegLibsInst->avcodec_get_context_defaults(mEncAudioCodecCtx);
+   FFMPEG_LIB(avcodec_get_context_defaults(mEncAudioCodecCtx));
 
    mEncAudioCodecCtx->codec_id = ExportFFmpegOptions::fmts[mSubFormat].codecid;
    mEncAudioCodecCtx->codec_type = CODEC_TYPE_AUDIO;
-   mEncAudioCodecCtx->codec_tag = FFmpegLibsInst->av_codec_get_tag((const AVCodecTag **)mEncFormatCtx->oformat->codec_tag,mEncAudioCodecCtx->codec_id);
+   mEncAudioCodecCtx->codec_tag = FFMPEG_LIB(av_codec_get_tag((const AVCodecTag **)mEncFormatCtx->oformat->codec_tag,mEncAudioCodecCtx->codec_id));
    mSampleRate = (int)project->GetRate();
    mEncAudioCodecCtx->global_quality = -99999; //quality mode is off by default;
 
@@ -448,7 +472,7 @@ bool ExportFFmpeg::InitCodecs(AudacityPr
    //mEncAudioCodecCtx->strict_std_compliance = FF_COMPLIANCE_STRICT;
 
    // Is the required audio codec compiled into libavcodec?
-   if ((codec = FFmpegLibsInst->avcodec_find_encoder(mEncAudioCodecCtx->codec_id)) == NULL)
+   if ((codec = FFMPEG_LIB(avcodec_find_encoder(mEncAudioCodecCtx->codec_id))) == NULL)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't find audio codec 0x%x."),mEncAudioCodecCtx->codec_id);
       wxMessageBox(wxString::Format(_("FFmpeg cannot find audio codec 0x%x.\nSupport for this codec is probably not compiled in."),mEncAudioCodecCtx->codec_id));
@@ -462,7 +486,7 @@ bool ExportFFmpeg::InitCodecs(AudacityPr
    }
 
    // Open the codec.
-   if (FFmpegLibsInst->avcodec_open(mEncAudioCodecCtx, codec) < 0 || mEncAudioCodecCtx->frame_size == 0) 
+   if (FFMPEG_LIB(avcodec_open(mEncAudioCodecCtx, codec)) < 0 || mEncAudioCodecCtx->frame_size == 0) 
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't open audio codec 0x%x."),mEncAudioCodecCtx->codec_id);
       return false;
@@ -475,7 +499,7 @@ bool ExportFFmpeg::InitCodecs(AudacityPr
       mEncAudioEncodedBufSiz = FF_MIN_BUFFER_SIZE;
    }
    // Allocate a buffer for the encoder to store encoded audio frames into.
-   if ((mEncAudioEncodedBuf = (uint8_t*)FFmpegLibsInst->av_malloc(mEncAudioEncodedBufSiz)) == NULL)
+   if ((mEncAudioEncodedBuf = (uint8_t*)FFMPEG_LIB(av_malloc(mEncAudioEncodedBufSiz))) == NULL)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't allocate buffer to hold encoded audio."));
       return false;
@@ -485,13 +509,13 @@ bool ExportFFmpeg::InitCodecs(AudacityPr
    // guarantee we'll get this minimum each time an audio frame is decoded from the input file so 
    // we use a FIFO to store up incoming raw samples until we have enough for one call to the codec.
 #if FFMPEG_STABLE
-   FFmpegLibsInst->av_fifo_init(&mEncAudioFifo, 1024);
+   FFMPEG_LIB(av_fifo_init(&mEncAudioFifo, 1024));
 #else
-   mEncAudioFifo = FFmpegLibsInst->av_fifo_alloc(1024);
+   mEncAudioFifo = FFMPEG_LIB(av_fifo_alloc(1024));
 #endif
 
    // Allocate a buffer to read OUT of the FIFO into. The FIFO maintains its own buffer internally.
-   if ((mEncAudioFifoOutBuf = (uint8_t*)FFmpegLibsInst->av_malloc(2*MAX_AUDIO_PACKET_SIZE)) == NULL)
+   if ((mEncAudioFifoOutBuf = (uint8_t*)FFMPEG_LIB(av_malloc(2*MAX_AUDIO_PACKET_SIZE))) == NULL)
    {
       wxLogMessage(wxT("FFmpeg : ERROR - Can't allocate buffer to read into from audio FIFO."));
       return false;
@@ -509,9 +533,9 @@ bool ExportFFmpeg::Finalize()
    {
       AVPacket	pkt;
 #if FFMPEG_STABLE
-      int		nFifoBytes = FFmpegLibsInst->av_fifo_size(&mEncAudioFifo);	// any bytes left in audio FIFO?
+      int		nFifoBytes = FFMPEG_LIB(av_fifo_size(&mEncAudioFifo));	// any bytes left in audio FIFO?
 #else
-      int		nFifoBytes = FFmpegLibsInst->av_fifo_size(mEncAudioFifo);	// any bytes left in audio FIFO?
+      int		nFifoBytes = FFMPEG_LIB(av_fifo_size(mEncAudioFifo));	// any bytes left in audio FIFO?
 #endif
 
       nEncodedBytes = 0;
@@ -550,15 +574,15 @@ bool ExportFFmpeg::Finalize()
 
             // Pull the bytes out from the FIFO and feed them to the encoder.
 #if FFMPEG_STABLE
-            if (FFmpegLibsInst->av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes) == 0)
+            if (FFMPEG_LIB(av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes)) == 0)
 #else
-            if (FFmpegLibsInst->av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes, NULL) == 0)
+            if (FFMPEG_LIB(av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes, NULL)) == 0)
 #endif
             {
                if (mEncAudioCodecCtx->frame_size != 1)
-                  nEncodedBytes = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, (int16_t*)mEncAudioFifoOutBuf);
+                  nEncodedBytes = FFMPEG_LIB(avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, (int16_t*)mEncAudioFifoOutBuf));
                else
-                  nEncodedBytes = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, nFifoBytes, (int16_t*)mEncAudioFifoOutBuf);
+                  nEncodedBytes = FFMPEG_LIB(avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, nFifoBytes, (int16_t*)mEncAudioFifoOutBuf));
             }
 
             mEncAudioCodecCtx->frame_size = nFrameSizeTmp;		// restore the native frame size
@@ -567,13 +591,13 @@ bool ExportFFmpeg::Finalize()
 
       // Now flush the encoder.
       if (nEncodedBytes <= 0)
-         nEncodedBytes = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, NULL);
+         nEncodedBytes = FFMPEG_LIB(avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, NULL));
 
       if (nEncodedBytes <= 0)			
          break;
 
       // Okay, we got a final encoded frame we can write to the output file.
-      FFmpegLibsInst->av_init_packet(&pkt);
+      FFMPEG_LIB(av_init_packet(&pkt));
 
       pkt.stream_index = mEncAudioStream->index;
       pkt.data = mEncAudioEncodedBuf;
@@ -582,9 +606,9 @@ bool ExportFFmpeg::Finalize()
 
       // Set presentation time of frame (currently in the codec's timebase) in the stream timebase.
       if(mEncAudioCodecCtx->coded_frame && mEncAudioCodecCtx->coded_frame->pts != int64_t(AV_NOPTS_VALUE))
-         pkt.pts = FFmpegLibsInst->av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+         pkt.pts = FFMPEG_LIB(av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base));
 
-      if (FFmpegLibsInst->av_interleaved_write_frame(mEncFormatCtx, &pkt) != 0)
+      if (FFMPEG_LIB(av_interleaved_write_frame(mEncFormatCtx, &pkt)) != 0)
       {
          wxLogMessage(wxT("FFmpeg : ERROR - Couldn't write last audio frame to output file."));
          break;
@@ -593,34 +617,34 @@ bool ExportFFmpeg::Finalize()
 
    // Close the codecs.
    if (mEncAudioStream != NULL)
-      FFmpegLibsInst->avcodec_close(mEncAudioStream->codec);
+      FFMPEG_LIB(avcodec_close(mEncAudioStream->codec));
 
    // Write any file trailers.
-   FFmpegLibsInst->av_write_trailer(mEncFormatCtx);
+   FFMPEG_LIB(av_write_trailer(mEncFormatCtx));
 
    for (i = 0; i < (int)mEncFormatCtx->nb_streams; i++)
    {
-      FFmpegLibsInst->av_freep(&mEncFormatCtx->streams[i]->codec);
-      FFmpegLibsInst->av_freep(&mEncFormatCtx->streams[i]);
+      FFMPEG_LIB(av_freep(&mEncFormatCtx->streams[i]->codec));
+      FFMPEG_LIB(av_freep(&mEncFormatCtx->streams[i]));
    }
 
    // Close the output file if we created it.
    if (!(mEncFormatDesc->flags & AVFMT_NOFILE))
-      FFmpegLibsInst->url_fclose(mEncFormatCtx->pb);
+      FFMPEG_LIB(url_fclose(mEncFormatCtx->pb));
 
    // Free any buffers or structures we allocated.
-   FFmpegLibsInst->av_free(mEncFormatCtx);
+   FFMPEG_LIB(av_free(mEncFormatCtx));
 
    if (mEncAudioEncodedBuf != NULL)
-      FFmpegLibsInst->av_free(mEncAudioEncodedBuf);
+      FFMPEG_LIB(av_free(mEncAudioEncodedBuf));
 
    if (mEncAudioFifoOutBuf != NULL)
-      FFmpegLibsInst->av_free(mEncAudioFifoOutBuf);
+      FFMPEG_LIB(av_free(mEncAudioFifoOutBuf));
 
 #if FFMPEG_STABLE
-   FFmpegLibsInst->av_fifo_free(&mEncAudioFifo);
+   FFMPEG_LIB(av_fifo_free(&mEncAudioFifo));
 #else
-   FFmpegLibsInst->av_fifo_free(mEncAudioFifo);
+   FFMPEG_LIB(av_fifo_free(mEncAudioFifo));
    mEncAudioFifo = NULL;
 #endif
    return true;
@@ -638,33 +662,33 @@ bool ExportFFmpeg::EncodeAudioFrame(int1
    nBytesToWrite = frameSize;
    pRawSamples  = (uint8_t*)pFrame;
 #if FFMPEG_STABLE
-   FFmpegLibsInst->av_fifo_realloc(&mEncAudioFifo, FFmpegLibsInst->av_fifo_size(&mEncAudioFifo) + frameSize);
+   FFMPEG_LIB(av_fifo_realloc(&mEncAudioFifo, FFMPEG_LIB(av_fifo_size(&mEncAudioFifo)) + frameSize));
 #else
-   FFmpegLibsInst->av_fifo_realloc2(mEncAudioFifo, FFmpegLibsInst->av_fifo_size(mEncAudioFifo) + frameSize);
+   FFMPEG_LIB(av_fifo_realloc2(mEncAudioFifo, FFMPEG_LIB(av_fifo_size(mEncAudioFifo)) + frameSize));
 #endif
    // Put the raw audio samples into the FIFO.
 #if FFMPEG_STABLE
-   ret = FFmpegLibsInst->av_fifo_generic_write(&mEncAudioFifo, pRawSamples, nBytesToWrite,NULL);
+   ret = FFMPEG_LIB(av_fifo_generic_write(&mEncAudioFifo, pRawSamples, nBytesToWrite,NULL));
 #else
-   ret = FFmpegLibsInst->av_fifo_generic_write(mEncAudioFifo, pRawSamples, nBytesToWrite,NULL);
+   ret = FFMPEG_LIB(av_fifo_generic_write(mEncAudioFifo, pRawSamples, nBytesToWrite,NULL));
 #endif
    wxASSERT(ret == nBytesToWrite);
 
    // Read raw audio samples out of the FIFO in nAudioFrameSizeOut byte-sized groups to encode.
 #if FFMPEG_STABLE
-   while ((ret = FFmpegLibsInst->av_fifo_size(&mEncAudioFifo)) >= nAudioFrameSizeOut)
+   while ((ret = FFMPEG_LIB(av_fifo_size(&mEncAudioFifo))) >= nAudioFrameSizeOut)
    {
-      ret = FFmpegLibsInst->av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut);
+      ret = FFMPEG_LIB(av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut));
 #else
-   while ((ret = FFmpegLibsInst->av_fifo_size(mEncAudioFifo)) >= nAudioFrameSizeOut)
+   while ((ret = FFMPEG_LIB(av_fifo_size(mEncAudioFifo))) >= nAudioFrameSizeOut)
    {
-      ret = FFmpegLibsInst->av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut, NULL);
+      ret = FFMPEG_LIB(av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut, NULL));
 #endif
-      FFmpegLibsInst->av_init_packet(&pkt);
+      FFMPEG_LIB(av_init_packet(&pkt));
 
-      pkt.size = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, 
+      pkt.size = FFMPEG_LIB(avcodec_encode_audio(mEncAudioCodecCtx, 
          mEncAudioEncodedBuf, mEncAudioEncodedBufSiz,		// out
-         (int16_t*)mEncAudioFifoOutBuf);				// in
+         (int16_t*)mEncAudioFifoOutBuf));				// in
       if (mEncAudioCodecCtx->frame_size == 1) { wxASSERT(pkt.size == mEncAudioEncodedBufSiz); }
       if (pkt.size < 0)
       {
@@ -674,7 +698,7 @@ bool ExportFFmpeg::EncodeAudioFrame(int1
 
       // Rescale from the codec time_base to the AVStream time_base.
       if (mEncAudioCodecCtx->coded_frame && mEncAudioCodecCtx->coded_frame->pts != int64_t(AV_NOPTS_VALUE))
-         pkt.pts = FFmpegLibsInst->av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base);
+         pkt.pts = FFMPEG_LIB(av_rescale_q(mEncAudioCodecCtx->coded_frame->pts, mEncAudioCodecCtx->time_base, mEncAudioStream->time_base));
       //wxLogMessage(wxT("FFmpeg : (%d) Writing audio frame with PTS: %lld."), mEncAudioCodecCtx->frame_number, pkt.pts);
 
       pkt.stream_index = mEncAudioStream->index;
@@ -682,7 +706,7 @@ bool ExportFFmpeg::EncodeAudioFrame(int1
       pkt.flags |= PKT_FLAG_KEY;
 
       // Write the encoded audio frame to the output file.
-      if ((ret = FFmpegLibsInst->av_interleaved_write_frame(mEncFormatCtx, &pkt)) != 0)
+      if ((ret = FFMPEG_LIB(av_interleaved_write_frame(mEncFormatCtx, &pkt))) != 0)
       {
          wxLogMessage(wxT("FFmpeg : ERROR - Failed to write audio frame to file."));
          return false;
@@ -696,8 +720,10 @@ int ExportFFmpeg::Export(AudacityProject
                        int channels, wxString fName,
                        bool selectionOnly, double t0, double t1, MixerSpec *mixerSpec, Tags *metadata, int subformat)
 {
+#ifndef USE_SYSTEM_FFMPEG
    if (!CheckFFmpegPresence())
       return false;
+#endif //USE_SYSTEM_FFMPEG
    mChannels = channels;
    // subformat index may not correspond directly to fmts[] index, convert it
    mSubFormat = AdjustFormatIndex(subformat);
@@ -871,8 +897,10 @@ int ExportFFmpeg::AskResample(int bitrat
 
 bool ExportFFmpeg::DisplayOptions(wxWindow *parent, int format)
 {
+#ifndef USE_SYSTEM_FFMPEG
    if (!CheckFFmpegPresence())
       return false;
+#endif //USE_SYSTEM_FFMPEG
    // subformat index may not correspond directly to fmts[] index, convert it
    mSubFormat = AdjustFormatIndex(format);
    if (mSubFormat == FMT_M4A)
--- audacity-1.3.12.orig/src/export/ExportFFmpegDialogs.cpp
+++ audacity-1.3.12/src/export/ExportFFmpegDialogs.cpp
@@ -73,8 +73,6 @@
 
 #if defined(USE_FFMPEG)
 
-extern FFmpegLibs *FFmpegLibsInst;
-
 /// This construction defines a enumeration of UI element IDs, and a static
 /// array of their string representations (this way they're always synchronized).
 /// Do not store the enumerated values in external files, as they may change;
@@ -1291,7 +1289,9 @@ ExportFFmpegOptions::~ExportFFmpegOption
 {
    delete mPresets;
    delete mPresetNames;
+#ifndef USE_SYSTEM_FFMPEG
    DropFFmpegLibs();
+#endif //USE_SYSTEM_FFMPEG
 }
 
 ExportFFmpegOptions::ExportFFmpegOptions(wxWindow *parent)
@@ -1299,13 +1299,17 @@ ExportFFmpegOptions::ExportFFmpegOptions
             wxString(_("Specify Other Options")))
 {
    ShuttleGui S(this, eIsCreatingFromPrefs);
+#ifndef USE_SYSTEM_FFMPEG
    PickFFmpegLibs();
+#endif //USE_SYSTEM_FFMPEG
    //FFmpegLibsInst->LoadLibs(NULL,true); //Loaded at startup or from Prefs now
 
    mPresets = new FFmpegPresets();
    mPresetNames = mPresets->GetPresetList();
 
+#ifndef USE_SYSTEM_FFMPEG
    if (FFmpegLibsInst->ValidLibsLoaded())
+#endif //USE_SYSTEM_FFMPEG
    {
       FetchFormatList();
       FetchCodecList();
@@ -1329,7 +1333,7 @@ ExportFFmpegOptions::ExportFFmpegOptions
       DoOnFormatList();
 
       //Select the codec that was selected last time this dialog was closed
-      AVCodec *codec = FFmpegLibsInst->avcodec_find_encoder((CodecID)gPrefs->Read(wxT("/FileFormats/FFmpegCodec"),(long)CODEC_ID_NONE));
+      AVCodec *codec = FFMPEG_LIB(avcodec_find_encoder((CodecID)gPrefs->Read(wxT("/FileFormats/FFmpegCodec"),(long)CODEC_ID_NONE)));
       if (codec != NULL) mCodecList->Select(mCodecList->FindString(wxString::FromUTF8(codec->name)));
       DoOnCodecList();
    }
@@ -1342,7 +1346,7 @@ void ExportFFmpegOptions::FetchFormatLis
 {
    // Enumerate all output formats
    AVOutputFormat *ofmt = NULL;
-   while ((ofmt = FFmpegLibsInst->av_oformat_next(ofmt)))
+   while ((ofmt = FFMPEG_LIB(av_oformat_next(ofmt))))
    {
       // Any audio-capable format has default audio codec.
       // If it doesn't, then it doesn't supports any audio codecs
@@ -1363,7 +1367,7 @@ void ExportFFmpegOptions::FetchCodecList
 {
    // Enumerate all codecs
    AVCodec *codec = NULL;
-   while ((codec = FFmpegLibsInst->av_codec_next(codec)))
+   while ((codec = FFMPEG_LIB(av_codec_next(codec))))
    {
       // We're only interested in audio and only in encoders
       if (codec->type == CODEC_TYPE_AUDIO && codec->encode)
@@ -1604,7 +1608,7 @@ int ExportFFmpegOptions::FetchCompatible
             break;
          }
          // Find the codec, that is claimed to be compatible
-         AVCodec *codec = FFmpegLibsInst->avcodec_find_encoder(CompatibilityList[i].codec);
+         AVCodec *codec = FFMPEG_LIB(avcodec_find_encoder(CompatibilityList[i].codec));
          // If it exists, is audio and has encoder
          if (codec != NULL && (codec->type == CODEC_TYPE_AUDIO) && codec->encode)
          {
@@ -1619,7 +1623,7 @@ int ExportFFmpegOptions::FetchCompatible
    if (found == 2)
    {
       AVCodec *codec = NULL;
-      while ((codec = FFmpegLibsInst->av_codec_next(codec)))
+      while ((codec = FFMPEG_LIB(av_codec_next(codec))))
       {
          if (codec->type == CODEC_TYPE_AUDIO && codec->encode)
          {
@@ -1637,10 +1641,14 @@ int ExportFFmpegOptions::FetchCompatible
    else if (found == 0)
    {
       wxCharBuffer buf = str.ToUTF8();
-      AVOutputFormat *format = FFmpegLibsInst->guess_format(buf,NULL,NULL);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+      AVOutputFormat *format = FFMPEG_LIB(guess_format(buf,NULL,NULL));
+#else
+      AVOutputFormat *format = FFMPEG_LIB(av_guess_format(buf,NULL,NULL));
+#endif
       if (format != NULL)
       {
-         AVCodec *codec = FFmpegLibsInst->avcodec_find_encoder(format->audio_codec);
+         AVCodec *codec = FFMPEG_LIB(avcodec_find_encoder(format->audio_codec));
          if (codec != NULL && (codec->type == CODEC_TYPE_AUDIO) && codec->encode)
          {
             if ((id >= 0) && codec->id == id) index = mShownCodecNames.GetCount();
@@ -1674,7 +1682,11 @@ int ExportFFmpegOptions::FetchCompatible
          if ((selfmt != NULL) && (selfmt->Cmp(CompatibilityList[i].fmt) == 0)) index = mShownFormatNames.GetCount();
          FromList.Add(CompatibilityList[i].fmt);
          mShownFormatNames.Add(CompatibilityList[i].fmt);
-         AVOutputFormat *tofmt = FFmpegLibsInst->guess_format(wxString(CompatibilityList[i].fmt).ToUTF8(),NULL,NULL);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+         AVOutputFormat *tofmt = FFMPEG_LIB(guess_format(wxString(CompatibilityList[i].fmt).ToUTF8(),NULL,NULL));
+#else
+         AVOutputFormat *tofmt = FFMPEG_LIB(av_guess_format(wxString(CompatibilityList[i].fmt).ToUTF8(),NULL,NULL));
+#endif
          if (tofmt != NULL) mShownFormatLongNames.Add(wxString::Format(wxT("%s - %s"),CompatibilityList[i].fmt,wxString::FromUTF8(tofmt->long_name).c_str()));
       }
    }
@@ -1694,7 +1706,7 @@ int ExportFFmpegOptions::FetchCompatible
    if (found)
    {
       // Find all formats which have this codec as default and which are not in the list yet and add them too
-      while ((ofmt = FFmpegLibsInst->av_oformat_next(ofmt)))
+      while ((ofmt = FFMPEG_LIB(av_oformat_next(ofmt))))
       {
          if (ofmt->audio_codec == id)
          {
@@ -1879,7 +1891,11 @@ void ExportFFmpegOptions::DoOnFormatList
    wxString *selcdclong = NULL;
    FindSelectedCodec(&selcdc, &selcdclong);
 
-   AVOutputFormat *fmt = FFmpegLibsInst->guess_format(selfmt->ToUTF8(),NULL,NULL);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+   AVOutputFormat *fmt = FFMPEG_LIB(guess_format(selfmt->ToUTF8(),NULL,NULL));
+#else
+   AVOutputFormat *fmt = FFMPEG_LIB(av_guess_format(selfmt->ToUTF8(),NULL,NULL));
+#endif
    if (fmt == NULL)
    {
       //This shouldn't really happen
@@ -1891,7 +1907,7 @@ void ExportFFmpegOptions::DoOnFormatList
 
    if (selcdc != NULL)
    {
-      AVCodec *cdc = FFmpegLibsInst->avcodec_find_encoder_by_name(selcdc->ToUTF8());
+      AVCodec *cdc = FFMPEG_LIB(avcodec_find_encoder_by_name(selcdc->ToUTF8()));
       if (cdc != NULL)
       {
          selcdcid = cdc->id;
@@ -1902,7 +1918,7 @@ void ExportFFmpegOptions::DoOnFormatList
 
    AVCodec *cdc = NULL;
    if (selcdc != NULL)
-      cdc = FFmpegLibsInst->avcodec_find_encoder_by_name(selcdc->ToUTF8());
+      cdc = FFMPEG_LIB(avcodec_find_encoder_by_name(selcdc->ToUTF8()));
    EnableDisableControls(cdc, selfmt);
    Layout();
    Fit();
@@ -1923,7 +1939,7 @@ void ExportFFmpegOptions::DoOnCodecList(
    wxString *selfmtlong = NULL;
    FindSelectedFormat(&selfmt, &selfmtlong);
 
-   AVCodec *cdc = FFmpegLibsInst->avcodec_find_encoder_by_name(selcdc->ToUTF8());
+   AVCodec *cdc = FFMPEG_LIB(avcodec_find_encoder_by_name(selcdc->ToUTF8()));
    if (cdc == NULL)
    {
       //This shouldn't really happen
@@ -1934,7 +1950,11 @@ void ExportFFmpegOptions::DoOnCodecList(
 
    if (selfmt != NULL)
    {
-      AVOutputFormat *fmt = FFmpegLibsInst->guess_format(selfmt->ToUTF8(),NULL,NULL);
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52, 64, 0)
+      AVOutputFormat *fmt = FFMPEG_LIB(guess_format(selfmt->ToUTF8(),NULL,NULL));
+#else
+      AVOutputFormat *fmt = FFMPEG_LIB(av_guess_format(selfmt->ToUTF8(),NULL,NULL));
+#endif
       if (fmt == NULL)
       {
          selfmt = NULL;
@@ -1971,7 +1991,7 @@ void ExportFFmpegOptions::OnOK(wxCommand
 {
    int selcdc = mCodecList->GetSelection();
    int selfmt = mFormatList->GetSelection();
-   if (selcdc > -1) gPrefs->Write(wxT("/FileFormats/FFmpegCodec"),(long)FFmpegLibsInst->avcodec_find_encoder_by_name(mCodecList->GetString(selcdc).ToUTF8())->id);
+   if (selcdc > -1) gPrefs->Write(wxT("/FileFormats/FFmpegCodec"),(long)FFMPEG_LIB(avcodec_find_encoder_by_name(mCodecList->GetString(selcdc).ToUTF8()))->id);
    if (selfmt > -1) gPrefs->Write(wxT("/FileFormats/FFmpegFormat"),mFormatList->GetString(selfmt));
    ShuttleGui S(this, eIsSavingToPrefs);
    PopulateOrExchange(S);
--- audacity-1.3.12.orig/src/import/ImportFFmpeg.cpp
+++ audacity-1.3.12/src/import/ImportFFmpeg.cpp
@@ -159,8 +159,6 @@ static const wxChar *exts[] =
 #include "../ondemand/ODDecodeFFmpegTask.h"
 #endif
 
-extern FFmpegLibs *FFmpegLibsInst;
-
 class FFmpegImportFileHandle;
 //moving from ImportFFmpeg.cpp to FFMpeg.h so other cpp files can use this struct.
 #ifndef EXPERIMENTAL_OD_FFMPEG
@@ -319,6 +317,7 @@ ImportFileHandle *FFmpegImportPlugin::Op
       //insdead of usual wxMessageBox()
       bool newsession = false;
       gPrefs->Read(wxT("/NewImportingSession"), &newsession);
+#ifndef USE_SYSTEM_FFMPEG
       if (!FFmpegLibsInst->ValidLibsLoaded())
       {
          int dontShowDlg;
@@ -332,12 +331,15 @@ ImportFileHandle *FFmpegImportPlugin::Op
             delete dlg;
          }         
       }
+#endif //USE_SYSTEM_FFMPEG
    }
+#ifndef USE_SYSTEM_FFMPEG
    if (!FFmpegLibsInst->ValidLibsLoaded())
    {
       delete handle;
       return NULL;
    }
+#endif //USE_SYSTEM_FFMPEG
 
    // Open the file for import  
    bool success = handle->Init();
@@ -353,7 +355,9 @@ ImportFileHandle *FFmpegImportPlugin::Op
 FFmpegImportFileHandle::FFmpegImportFileHandle(const wxString & name)
 :  ImportFileHandle(name)
 {
+#ifndef USE_SYSTEM_FFMPEG
    PickFFmpegLibs();
+#endif //USE_SYSTEM_FFMPEG
 
    mStreamInfo = new wxArrayString();
    mFormatContext = NULL;
@@ -371,9 +375,11 @@ bool FFmpegImportFileHandle::Init()
 {
    //FFmpegLibsInst->LoadLibs(NULL,false); //Loaded at startup or from Prefs now
 
+#ifndef USE_SYSTEM_FFMPEG
    if (!FFmpegLibsInst->ValidLibsLoaded()) return false;
+#endif //USE_SYSTEM_FFMPEG
 
-   FFmpegLibsInst->av_log_set_callback(av_log_wx_callback);
+   FFMPEG_LIB(av_log_set_callback(av_log_wx_callback));
 
    int err = ufile_fopen_input(&mFormatContext, mName);
    if (err < 0)
@@ -382,7 +388,7 @@ bool FFmpegImportFileHandle::Init()
       return false;
    }
 
-   err = FFmpegLibsInst->av_find_stream_info(mFormatContext);
+   err = FFMPEG_LIB(av_find_stream_info(mFormatContext));
    if (err < 0)
    {
       wxLogMessage(wxT("FFmpeg : av_find_stream_info() failed for file %s"),mName.c_str());
@@ -410,7 +416,7 @@ bool FFmpegImportFileHandle::InitCodecs(
          sc->m_stream = mFormatContext->streams[i];
          sc->m_codecCtx = sc->m_stream->codec;
 
-         AVCodec *codec = FFmpegLibsInst->avcodec_find_decoder(sc->m_codecCtx->codec_id);
+         AVCodec *codec = FFMPEG_LIB(avcodec_find_decoder(sc->m_codecCtx->codec_id));
          if (codec == NULL)
          {
             wxLogMessage(wxT("FFmpeg : avcodec_find_decoder() failed. Index[%02d], Codec[%02x - %s]"),i,sc->m_codecCtx->codec_id,sc->m_codecCtx->codec_name);
@@ -426,7 +432,7 @@ bool FFmpegImportFileHandle::InitCodecs(
             continue;
          }
 
-         if (FFmpegLibsInst->avcodec_open(sc->m_codecCtx, codec) < 0)
+         if (FFMPEG_LIB(avcodec_open(sc->m_codecCtx, codec) < 0))
          {
             wxLogMessage(wxT("FFmpeg : avcodec_open() failed. Index[%02d], Codec[%02x - %s]"),i,sc->m_codecCtx->codec_id,sc->m_codecCtx->codec_name);
             //Can't open decoder - skip this stream
@@ -631,7 +637,7 @@ int FFmpegImportFileHandle::Import(Track
 #if FFMPEG_STABLE
             av_free_packet(&sc->m_pkt);
 #else
-            FFmpegLibsInst->av_free_packet(&sc->m_pkt);
+            FFMPEG_LIB(av_free_packet(&sc->m_pkt));
 #endif
             sc->m_pktValid = 0;
          }    
@@ -652,7 +658,7 @@ int FFmpegImportFileHandle::Import(Track
 #if FFMPEG_STABLE
                av_free_packet(&mScs[i]->m_pkt);
 #else
-               FFmpegLibsInst->av_free_packet(&mScs[i]->m_pkt);
+               FFMPEG_LIB(av_free_packet(&mScs[i]->m_pkt));
 #endif
                mScs[i]->m_pktValid = 0;
             }				
@@ -707,7 +713,7 @@ streamContext *FFmpegImportFileHandle::R
    streamContext *sc = NULL;
    AVPacket pkt;
 
-   if (FFmpegLibsInst->av_read_frame(mFormatContext,&pkt) < 0)
+   if (FFMPEG_LIB(av_read_frame(mFormatContext,&pkt)) < 0)
    {
       return NULL;
    }
@@ -726,7 +732,7 @@ streamContext *FFmpegImportFileHandle::R
 #if FFMPEG_STABLE
       av_free_packet(&pkt);
 #else
-      FFmpegLibsInst->av_free_packet(&pkt);
+      FFMPEG_LIB(av_free_packet(&pkt));
 #endif
       return (streamContext*)1;
    }
@@ -772,10 +778,10 @@ int FFmpegImportFileHandle::DecodeFrame(
       //\warning { for some reason using the following macro call right in the function call
       // causes Audacity to crash in some unknown place. With "newsize" it works fine }
       int newsize = FFMAX(sc->m_pkt.size*sizeof(*sc->m_decodedAudioSamples), AVCODEC_MAX_AUDIO_FRAME_SIZE);
-      sc->m_decodedAudioSamples = (int16_t*)FFmpegLibsInst->av_fast_realloc(sc->m_decodedAudioSamples, 
+      sc->m_decodedAudioSamples = (int16_t*)FFMPEG_LIB(av_fast_realloc(sc->m_decodedAudioSamples, 
          &sc->m_decodedAudioSamplesSiz,
          newsize
-         );
+         ));
 
       if (sc->m_decodedAudioSamples == NULL)
       {
@@ -787,10 +793,10 @@ int FFmpegImportFileHandle::DecodeFrame(
    // avcodec_decode_audio2() expects the size of the output buffer as the 3rd parameter but
    // also returns the number of bytes it decoded in the same parameter.
    sc->m_decodedAudioSamplesValidSiz = sc->m_decodedAudioSamplesSiz;
-   nBytesDecoded = FFmpegLibsInst->avcodec_decode_audio2(sc->m_codecCtx, 
+   nBytesDecoded = FFMPEG_LIB(avcodec_decode_audio2(sc->m_codecCtx, 
       sc->m_decodedAudioSamples,		      // out
       &sc->m_decodedAudioSamplesValidSiz,	// in/out
-      pDecode, nDecodeSiz);				   // in
+      pDecode, nDecodeSiz));				   // in
 
    if (nBytesDecoded < 0)
    {
@@ -866,7 +872,7 @@ int FFmpegImportFileHandle::WriteData(st
    // Try to update the progress indicator (and see if user wants to cancel)
    int updateResult = eProgressSuccess;
    // PTS (presentation time) is the proper way of getting current position
-   if (sc->m_pkt.pts != AV_NOPTS_VALUE && mFormatContext->duration != AV_NOPTS_VALUE)
+   if (sc->m_pkt.pts != int64_t(AV_NOPTS_VALUE) && mFormatContext->duration != int64_t(AV_NOPTS_VALUE))
    {
       mProgressPos = sc->m_pkt.pts * sc->m_stream->time_base.num / sc->m_stream->time_base.den;
       mProgressLen = (mFormatContext->duration > 0 ? mFormatContext->duration / AV_TIME_BASE: 1);
@@ -912,16 +918,18 @@ FFmpegImportFileHandle::~FFmpegImportFil
    if(!mUsingOD)
    {
 #endif
+#ifndef USE_SYSTEM_FFMPEG
    if (FFmpegLibsInst->ValidLibsLoaded())
+#endif //USE_SYSTEM_FFMPEG
    {
-      if (mFormatContext) FFmpegLibsInst->av_close_input_file(mFormatContext);
-      FFmpegLibsInst->av_log_set_callback(FFmpegLibsInst->av_log_default_callback);
+      if (mFormatContext) FFMPEG_LIB(av_close_input_file(mFormatContext));
+      FFMPEG_LIB(av_log_set_callback(FFMPEG_LIB(av_log_default_callback)));
    }
 
    for (int i = 0; i < mNumStreams; i++)
    {
       if (mScs[i]->m_decodedAudioSamples != NULL)
-         FFmpegLibsInst->av_free(mScs[i]->m_decodedAudioSamples);
+         FFMPEG_LIB(av_free(mScs[i]->m_decodedAudioSamples));
 
       delete mScs[i];
    }
@@ -933,7 +941,9 @@ FFmpegImportFileHandle::~FFmpegImportFil
 
    delete mStreamInfo;
 
+#ifndef USE_SYSTEM_FFMPEG
    DropFFmpegLibs();
+#endif //USE_SYSTEM_FFMPEG
 }
 
 #endif //USE_FFMPEG
--- audacity-1.3.12.orig/src/prefs/LibraryPrefs.cpp
+++ audacity-1.3.12/src/prefs/LibraryPrefs.cpp
@@ -129,6 +129,10 @@ void LibraryPrefs::PopulateOrExchange(Sh
          S.Id(ID_FFMPEG_DOWN_BUTTON);
          wxButton *bdwn = S.AddButton(_("Dow&nload"),
                                       wxALL | wxALIGN_LEFT | wxALIGN_CENTRE_VERTICAL);
+#ifdef USE_SYSTEM_FFMPEG
+         bdwn->Enable(FALSE);
+         bfnd->Enable(FALSE);
+#endif //USE_SYSTEM_FFMPEG
 #if !defined(USE_FFMPEG)
          bdwn->Enable(FALSE);
          bfnd->Enable(FALSE);
@@ -163,12 +167,22 @@ void LibraryPrefs::OnMP3DownButton(wxCom
 
 void LibraryPrefs::SetFFmpegVersionText()
 {
+#ifdef USE_SYSTEM_FFMPEG
+   int avcver = avcodec_version();
+   int avfver = avformat_version();
+   int avuver = avutil_version();
+   mFFmpegVersion->SetLabel(wxString::Format(wxT("F(%d.%d.%d),C(%d.%d.%d),U(%d.%d.%d)"),
+                                             avfver >> 16 & 0xFF, avfver >> 8 & 0xFF, avfver & 0xFF,
+                                             avcver >> 16 & 0xFF, avcver >> 8 & 0xFF, avcver & 0xFF,
+                                             avuver >> 16 & 0xFF, avuver >> 8 & 0xFF, avuver & 0xFF));
+#else //USE_SYSTEM_FFMPEG
    mFFmpegVersion->SetLabel(GetFFmpegVersion(this));
+#endif //USE_SYSTEM_FFMPEG
 }
 
 void LibraryPrefs::OnFFmpegFindButton(wxCommandEvent & e)
 {
-#ifdef USE_FFMPEG
+#ifndef USE_SYSTEM_FFMPEG
    FFmpegLibs* FFmpegLibsInst = PickFFmpegLibs();
    bool showerrs =
 #if defined(__WXDEBUG__)
@@ -200,7 +214,7 @@ void LibraryPrefs::OnFFmpegFindButton(wx
    SetFFmpegVersionText();
 
    DropFFmpegLibs();
-#endif
+#endif //USE_SYSTEM_FFMPEG
 }
 
 void LibraryPrefs::OnFFmpegDownButton(wxCommandEvent & e)
