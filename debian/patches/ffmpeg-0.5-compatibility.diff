Index: src/export/ExportFFmpeg.cpp
===================================================================
RCS file: /cvsroot/audacity/audacity-src/src/export/ExportFFmpeg.cpp,v
retrieving revision 1.62
diff -u -r1.62 ExportFFmpeg.cpp
--- src/export/ExportFFmpeg.cpp	14 Jul 2009 19:41:04 -0000	1.62
+++ src/export/ExportFFmpeg.cpp	28 Aug 2009 23:36:34 -0000
@@ -147,8 +147,12 @@
    AVStream        *	mEncAudioStream;			// the output audio stream (may remain NULL)
    AVCodecContext  *	mEncAudioCodecCtx;		// the encoder for the output audio stream
    uint8_t         *	mEncAudioEncodedBuf;		// buffer to hold frames encoded by the encoder
-   int			      mEncAudioEncodedBufSiz;		
+   int			          mEncAudioEncodedBufSiz;		
+#if FFMPEG_STABLE
+   AVFifoBuffer		    mEncAudioFifo;				// FIFO to write incoming audio samples into
+#else
    AVFifoBuffer		 *  mEncAudioFifo;				// FIFO to write incoming audio samples into
+#endif
    uint8_t         *	mEncAudioFifoOutBuf;		// buffer to read _out_ of the FIFO into
 
    wxString          mName;
@@ -227,6 +231,14 @@
 {
    bool result = true;
    int subFormat = AdjustFormatIndex(format);
+#if FFMPEG_STABLE
+   if (format == FMT_AMRNB || format == FMT_AMRWB)
+   {
+      wxMessageBox(_("Properly configured FFmpeg is required to proceed.\nYou can configure it at Preferences > Libraries.\n\nNote that AMR support is not available with our FFmpeg\ninstaller, but requires you compile FFmpeg yourself."), _("AMR support is not distributable"));
+      result = false;
+   }
+   else
+#endif
    if (!CheckFFmpegPresence())
    {
       result = false;
@@ -348,7 +360,7 @@
    switch (mSubFormat)
    {
    case FMT_M4A:
-      mEncAudioCodecCtx->bit_rate = 0;
+      mEncAudioCodecCtx->bit_rate = 98000;
       mEncAudioCodecCtx->bit_rate *= mChannels;
       mEncAudioCodecCtx->profile = FF_PROFILE_AAC_LOW;
       mEncAudioCodecCtx->cutoff = 0;
@@ -365,10 +377,12 @@
       mSampleRate = 8000;
       mEncAudioCodecCtx->bit_rate = gPrefs->Read(wxT("/FileFormats/AMRNBBitRate"), 12200);
       break;
-/*   case FMT_AMRWB:
+#if FFMPEG_STABLE
+   case FMT_AMRWB:
       mSampleRate = 16000;
       mEncAudioCodecCtx->bit_rate = gPrefs->Read(wxT("/FileFormats/AMRWBBitRate"), 23850);
-      break;*/
+      break;
+#endif
    case FMT_WMA2:
       mEncAudioCodecCtx->bit_rate = gPrefs->Read(wxT("/FileFormats/WMABitRate"), 198000);
       if (!CheckSampleRate(mSampleRate,ExportFFmpegWMAOptions::iWMASampleRates[0], ExportFFmpegWMAOptions::iWMASampleRates[4], &ExportFFmpegWMAOptions::iWMASampleRates[0]))
@@ -409,7 +423,11 @@
 
    if (mEncAudioCodecCtx->global_quality >= 0)
    {
-      mEncAudioCodecCtx->bit_rate = 0;
+/* I'm not sure this is required, regardless of FFmpeg version
+#if FFMPEG_STABLE
+     mEncAudioCodecCtx->bit_rate = 0;
+#endif
+*/
       mEncAudioCodecCtx->flags |= CODEC_FLAG_QSCALE;
    }
    else mEncAudioCodecCtx->global_quality = -99999;
@@ -458,8 +476,11 @@
    // The encoder may require a minimum number of raw audio samples for each encoding but we can't
    // guarantee we'll get this minimum each time an audio frame is decoded from the input file so 
    // we use a FIFO to store up incoming raw samples until we have enough for one call to the codec.
-   //FFmpegLibsInst->av_fifo_init(&mEncAudioFifo, 1024);
+#if FFMPEG_STABLE
+   FFmpegLibsInst->av_fifo_init(&mEncAudioFifo, 1024);
+#else
    mEncAudioFifo = FFmpegLibsInst->av_fifo_alloc(1024);
+#endif
 
    // Allocate a buffer to read OUT of the FIFO into. The FIFO maintains its own buffer internally.
    if ((mEncAudioFifoOutBuf = (uint8_t*)FFmpegLibsInst->av_malloc(2*MAX_AUDIO_PACKET_SIZE)) == NULL)
@@ -479,7 +500,11 @@
    for (;;)
    {
       AVPacket	pkt;
+#if FFMPEG_STABLE
+      int		nFifoBytes = FFmpegLibsInst->av_fifo_size(&mEncAudioFifo);	// any bytes left in audio FIFO?
+#else
       int		nFifoBytes = FFmpegLibsInst->av_fifo_size(mEncAudioFifo);	// any bytes left in audio FIFO?
+#endif
 
       nEncodedBytes = 0;
       int		nAudioFrameSizeOut = mEncAudioCodecCtx->frame_size * mEncAudioCodecCtx->channels * sizeof(int16_t);
@@ -516,7 +541,11 @@
                nFifoBytes, mEncAudioCodecCtx->frame_size);
 
             // Pull the bytes out from the FIFO and feed them to the encoder.
+#if FFMPEG_STABLE
+            if (FFmpegLibsInst->av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes) == 0)
+#else
             if (FFmpegLibsInst->av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes, NULL) == 0)
+#endif
             {
                if (mEncAudioCodecCtx->frame_size != 1)
                   nEncodedBytes = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, (int16_t*)mEncAudioFifoOutBuf);
@@ -580,8 +609,12 @@
    if (mEncAudioFifoOutBuf != NULL)
       FFmpegLibsInst->av_free(mEncAudioFifoOutBuf);
 
+#if FFMPEG_STABLE
+   FFmpegLibsInst->av_fifo_free(&mEncAudioFifo);
+#else
    FFmpegLibsInst->av_fifo_free(mEncAudioFifo);
    mEncAudioFifo = NULL;
+#endif
    return true;
 }
 
@@ -596,15 +629,29 @@
 
    nBytesToWrite = frameSize;
    pRawSamples  = (uint8_t*)pFrame;
+#if FFMPEG_STABLE
+   FFmpegLibsInst->av_fifo_realloc(&mEncAudioFifo, FFmpegLibsInst->av_fifo_size(&mEncAudioFifo) + frameSize);
+#else
    FFmpegLibsInst->av_fifo_realloc2(mEncAudioFifo, FFmpegLibsInst->av_fifo_size(mEncAudioFifo) + frameSize);
+#endif
    // Put the raw audio samples into the FIFO.
+#if FFMPEG_STABLE
+   ret = FFmpegLibsInst->av_fifo_generic_write(&mEncAudioFifo, pRawSamples, nBytesToWrite,NULL);
+#else
    ret = FFmpegLibsInst->av_fifo_generic_write(mEncAudioFifo, pRawSamples, nBytesToWrite,NULL);
+#endif
    wxASSERT(ret == nBytesToWrite);
 
    // Read raw audio samples out of the FIFO in nAudioFrameSizeOut byte-sized groups to encode.
+#if FFMPEG_STABLE
+   while ((ret = FFmpegLibsInst->av_fifo_size(&mEncAudioFifo)) >= nAudioFrameSizeOut)
+   {
+      ret = FFmpegLibsInst->av_fifo_read(&mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut);
+#else
    while ((ret = FFmpegLibsInst->av_fifo_size(mEncAudioFifo)) >= nAudioFrameSizeOut)
    {
       ret = FFmpegLibsInst->av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut, NULL);
+#endif
       FFmpegLibsInst->av_init_packet(&pkt);
 
       pkt.size = FFmpegLibsInst->avcodec_encode_audio(mEncAudioCodecCtx, 
@@ -838,12 +885,14 @@
       od.ShowModal();
       return true;
    }
-/*   else if (mSubFormat == FMT_AMRWB)
+#if FFMPEG_STABLE
+   else if (mSubFormat == FMT_AMRWB)
    {
       ExportFFmpegAMRWBOptions od(parent);
       od.ShowModal();
       return true;
-   }*/
+   }
+#endif
    else if (mSubFormat == FMT_WMA2)
    {
       ExportFFmpegWMAOptions od(parent);
Index: src/export/ExportFFmpegDialogs.h
===================================================================
RCS file: /cvsroot/audacity/audacity-src/src/export/ExportFFmpegDialogs.h,v
retrieving revision 1.11
diff -u -r1.11 ExportFFmpegDialogs.h
--- src/export/ExportFFmpegDialogs.h	14 Jul 2009 19:41:04 -0000	1.11
+++ src/export/ExportFFmpegDialogs.h	28 Aug 2009 23:34:54 -0000
@@ -27,7 +27,9 @@
    FMT_M4A,
    FMT_AC3,
    FMT_AMRNB,
-//   FMT_AMRWB,
+#if FFMPEG_STABLE
+   FMT_AMRWB,
+#endif
    FMT_WMA2,
    FMT_OTHER,
    FMT_LAST
@@ -54,7 +56,9 @@
    {FMT_M4A,         wxT("M4A"),     wxT("m4a"),  wxT("ipod"), 48,  true ,true ,_("M4A (AAC) Files (FFmpeg)"),         CODEC_ID_AAC,    true},
    {FMT_AC3,         wxT("AC3"),     wxT("ac3"),  wxT("ac3"),  7,   false,false,_("AC3 Files (FFmpeg)"),               CODEC_ID_AC3,    true},
    {FMT_AMRNB,       wxT("AMRNB"),   wxT("amr"),  wxT("amr"),  1,   false,false,_("AMR (narrow band) Files (FFmpeg)"), CODEC_ID_AMR_NB, true},
-//   {FMT_AMRWB,       wxT("AMRWB"),   wxT("amr"),  wxT("amr"),  1,   false,false,_("AMR (wide band) Files (FFmpeg)"),   CODEC_ID_AMR_WB, true},
+#if FFMPEG_STABLE
+   {FMT_AMRWB,       wxT("AMRWB"),   wxT("amr"),  wxT("amr"),  1,   false,false,_("AMR (wide band) Files (FFmpeg)"),   CODEC_ID_AMR_WB, true},
+#endif
    {FMT_WMA2,        wxT("WMA"),     wxT("wma"),  wxT("asf"),  2,   true ,false,_("WMA (version 2) Files (FFmpeg)"),   CODEC_ID_WMAV2,  true},
    {FMT_OTHER,       wxT("FFMPEG"),  wxT(""),     wxT(""),     255, true ,true ,_("Custom FFmpeg Export"),             CODEC_ID_NONE,   true}
 };
Index: src/FFmpeg.cpp
===================================================================
RCS file: /cvsroot/audacity/audacity-src/src/FFmpeg.cpp,v
retrieving revision 1.42
diff -u -r1.42 FFmpeg.cpp
--- src/FFmpeg.cpp	12 Jul 2009 11:26:09 -0000	1.42
+++ src/FFmpeg.cpp	28 Aug 2009 23:47:08 -0000
@@ -816,9 +816,14 @@
    INITDYN(avformat,get_buffer);
    INITDYN(avformat,match_ext);
 
-   INITDYN(codec,avcodec_init);
+#if FFMPEG_STABLE
+   INITDYN(avformat,av_init_packet);
+#else
    INITDYN(codec,av_init_packet);
    INITDYN(codec,av_free_packet);
+#endif
+
+   INITDYN(codec,avcodec_init);
    INITDYN(codec,avcodec_find_encoder);
    INITDYN(codec,avcodec_find_encoder_by_name);
    INITDYN(codec,avcodec_find_decoder);
@@ -843,13 +848,19 @@
    INITDYN(util,av_free);
    INITDYN(util,av_log_set_callback);
    INITDYN(util,av_log_default_callback);
+#if FFMPEG_STABLE
+   INITDYN(util,av_fifo_init);
+   INITDYN(util,av_fifo_read);
+   INITDYN(util,av_fifo_realloc);
+#else
    INITDYN(util,av_fifo_alloc);
-   INITDYN(util,av_fifo_free);
    INITDYN(util,av_fifo_generic_read);
-   INITDYN(util,av_fifo_size);
-   INITDYN(util,av_fifo_generic_write);
    INITDYN(util,av_fifo_realloc2);
+#endif
+   INITDYN(util,av_fifo_free);
+   INITDYN(util,av_fifo_size);
    INITDYN(util,av_malloc);
+   INITDYN(util,av_fifo_generic_write);
    INITDYN(util,av_freep);
    INITDYN(util,av_rescale_q);
    INITDYN(util,av_strstart);
Index: src/FFmpeg.h
===================================================================
RCS file: /cvsroot/audacity/audacity-src/src/FFmpeg.h,v
retrieving revision 1.42
diff -u -r1.42 FFmpeg.h
--- src/FFmpeg.h	12 Jul 2009 11:26:09 -0000	1.42
+++ src/FFmpeg.h	28 Aug 2009 23:43:37 -0000
@@ -35,6 +35,7 @@
    // knowing the value of EINVAL...see bottom of avcodec.h.  Not doing
    // so will produce positive error returns when they should be < 0.
    #include <errno.h>
+
    #include <libavcodec/avcodec.h>
    #include <libavformat/avformat.h>
    #include <libavutil/fifo.h>
@@ -72,6 +73,14 @@
 
 /* from here on in, this stuff only applies when ffmpeg is available */
 #if defined(USE_FFMPEG)
+
+/* This is a bit shortsighted (matches only 0.5 exactly), but i can't come up with anything smarter at the moment */
+#if LIBAVFORMAT_VERSION_MAJOR == 52 && LIBAVFORMAT_VERSION_MINOR == 31 && LIBAVCODEC_VERSION_MAJOR == 52 && LIBAVCODEC_VERSION_MINOR == 20
+#define FFMPEG_STABLE 1
+#else
+#define FFMPEG_STABLE 0
+#endif
+
 int ufile_fopen(ByteIOContext **s, const wxString & name, int flags);
 
 #if defined(__WXMSW__)
@@ -218,19 +227,22 @@
    int               (*av_interleaved_write_frame)    (AVFormatContext *s, AVPacket *pkt);
    int               (*av_write_frame)                (AVFormatContext *s, AVPacket *pkt);
    void              (*av_init_packet)                (AVPacket *pkt);
-   void              (*av_free_packet)                (AVPacket *pkt);
-   //int               (*av_fifo_init)                  (AVFifoBuffer *f, int size);
-   AVFifoBuffer*     (*av_fifo_alloc)                 (unsigned int size);
+   int               (*av_fifo_generic_write)         (AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));   
    void              (*av_fifo_free)                  (AVFifoBuffer *f);
-//   int               (*av_fifo_read)                  (AVFifoBuffer *f, uint8_t *buf, int buf_size);
-   int               (*av_fifo_generic_read)          (AVFifoBuffer *f, uint8_t *buf, int buf_size, int (*func)(void*, void*, int));
    int               (*av_fifo_size)                  (AVFifoBuffer *f);
-   int               (*av_fifo_generic_write)         (AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));
-//   void              (*av_fifo_realloc)               (AVFifoBuffer *f, unsigned int size);
-   int               (*av_fifo_realloc2)              (AVFifoBuffer *f, unsigned int size);
    void*             (*av_malloc)                     (unsigned int size);
    void              (*av_freep)                      (void *ptr);
    int64_t           (*av_rescale_q)                  (int64_t a, AVRational bq, AVRational cq);
+#if !FFMPEG_STABLE
+   void              (*av_free_packet)                (AVPacket *pkt);
+   AVFifoBuffer*     (*av_fifo_alloc)                 (unsigned int size);
+   int               (*av_fifo_generic_read)          (AVFifoBuffer *f, uint8_t *buf, int buf_size, int (*func)(void*, void*, int));
+   int               (*av_fifo_realloc2)              (AVFifoBuffer *f, unsigned int size);
+#else
+   int               (*av_fifo_init)                  (AVFifoBuffer *f, int size);
+   int               (*av_fifo_read)                  (AVFifoBuffer *f, uint8_t *buf, int buf_size);
+   void              (*av_fifo_realloc)               (AVFifoBuffer *f, unsigned int size);
+#endif
 
    ///! Finds libav* libraries
    ///\return true if found, false if not found
Index: src/import/ImportFFmpeg.cpp
===================================================================
RCS file: /cvsroot/audacity/audacity-src/src/import/ImportFFmpeg.cpp,v
retrieving revision 1.34
diff -u -r1.34 ImportFFmpeg.cpp
--- src/import/ImportFFmpeg.cpp	12 Jul 2009 11:26:09 -0000	1.34
+++ src/import/ImportFFmpeg.cpp	28 Aug 2009 23:23:19 -0000
@@ -558,7 +558,11 @@
          // Cleanup after frame decoding
          if (sc->m_pktValid)
          {
+#if FFMPEG_STABLE
+            av_free_packet(&sc->m_pkt);
+#else
             FFmpegLibsInst->av_free_packet(&sc->m_pkt);
+#endif
             sc->m_pktValid = 0;
          }    
       }
@@ -575,7 +579,11 @@
 
             if (mScs[i]->m_pktValid)
             {
+#if FFMPEG_STABLE
+               av_free_packet(&mScs[i]->m_pkt);
+#else
                FFmpegLibsInst->av_free_packet(&mScs[i]->m_pkt);
+#endif
                mScs[i]->m_pktValid = 0;
             }				
          }
@@ -644,7 +652,11 @@
    // When not all streams are selected for import this will happen very often.
    if (sc == NULL)
    {
+#if FFMPEG_STABLE
+      av_free_packet(&pkt);
+#else
       FFmpegLibsInst->av_free_packet(&pkt);
+#endif
       return (streamContext*)1;
    }
 
